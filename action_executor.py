"""
Executes actions generated by the vision planning system.
"""
import time
import random
from dataclasses import dataclass
from typing import Tuple, Optional, List, Callable
from enum import Enum

from playwright.sync_api import Page
from models import ActionStep, ActionType, PageElements, PageInfo
from handlers import UploadHandler
from utils import SelectorUtils
from unittest.mock import Mock
from utils.page_utils import PageUtils
from utils.context_guard import ContextGuard, GuardDecision
from vision_utils import get_gemini_box_2d_center_pixels
from session_tracker import SessionTracker, InteractionType
from interaction_deduper import InteractionDeduper
from action_ledger import ActionLedger


class ScrollReason(Enum):
    """Enum for different scroll reasons"""
    USER_ACTION = "user_action"  # User explicitly requested a scroll action
    DUPLICATE_REJECTION = "duplicate_rejection"  # Scrolled due to repeated duplicate element detection
    DOM_UNCHANGED = "dom_unchanged"  # Scrolled because DOM signature hasn't changed
    EXPLORE_CONTENT = "explore_content"  # Scrolled to explore more content after successful plan execution
    MANUAL = "manual"  # Default for programmatic scrolls


@dataclass
class PreActionContext:
    """Complete context information passed to pre-action callbacks"""
    action_type: ActionType
    step: ActionStep
    page_info: PageInfo
    elements: PageElements
    coordinates: Optional[Tuple[int, int]] = None
    page: Optional[Page] = None  # Access to the page for custom actions
    action_id: Optional[str] = None  # ID of the action that triggered this action
    action_lineage: Optional[List[str]] = None  # Full lineage of action IDs


@dataclass
class PostActionContext:
    """Complete context information passed to post-action callbacks"""
    action_type: ActionType
    success: bool
    step: ActionStep
    page_info: PageInfo
    elements: PageElements
    coordinates: Optional[Tuple[int, int]] = None
    error_message: Optional[str] = None
    page: Optional[Page] = None  # Access to the page for custom actions
    action_id: Optional[str] = None  # ID of the action that triggered this action
    action_lineage: Optional[List[str]] = None  # Full lineage of action IDs
    scroll_occurred: bool = False  # Whether a scroll happened
    scroll_reason: Optional[ScrollReason] = None  # Reason for scroll (see ScrollReason enum)


class ActionExecutor:
    """Executes automation actions"""
    
    def __init__(self, page: Page, session_tracker: SessionTracker, page_utils:PageUtils=None, deduper: InteractionDeduper=None, action_ledger: ActionLedger=None, preferred_click_method: str = "programmatic", execute_action_callback: Optional[Callable[[str], bool]] = None, user_messages_config=None):
        self.page = page
        self.session_tracker = session_tracker
        self.page_utils = page_utils
        self.deduper = deduper or InteractionDeduper()
        self.action_ledger = action_ledger or ActionLedger()
        self.execute_action_callback = execute_action_callback  # Callback to execute actions through bot infrastructure
        self.last_failure_reason: Optional[str] = None
        self.user_messages_config = user_messages_config  # Store user messages config
        
        # Click method configuration
        if preferred_click_method not in ["programmatic", "mouse"]:
            raise ValueError(f"preferred_click_method must be 'programmatic' or 'mouse', got '{preferred_click_method}'")
        self.preferred_click_method = preferred_click_method  # "programmatic" or "mouse"
        
        # Scroll tracking
        self.last_scroll_occurred: bool = False
        self.last_scroll_reason: Optional[ScrollReason] = None
        
        # Click retry tracking: track previous clicks to detect when page hasn't changed
        self.last_click_selector: Optional[str] = None
        self.last_click_url: Optional[str] = None
        self.last_click_dom_signature: Optional[str] = None
        self.last_click_method: str = preferred_click_method
        
        # Initialize specialized handlers
        # DateTimeHandler may still need goal_monitor for compatibility, but we'll update it
        # For now, pass session_tracker instead
        try:
            from handlers.datetime_handler import DateTimeHandler
            self.datetime_handler = DateTimeHandler(page, session_tracker)
        except Exception:
            # Fallback if DateTimeHandler hasn't been updated yet
            self.datetime_handler = None
        self.upload_handler = UploadHandler(page, user_messages_config=user_messages_config)
        self.selector_utils = SelectorUtils(page)
        # ContextGuard doesn't need element_analyzer anymore
        self.context_guard = ContextGuard(page, None)
        
        # Vision-assisted refinements
        self.enable_vision_tag_hint: bool = True
        
        # Get event logger directly
        from utils.event_logger import get_event_logger
        self.event_logger = get_event_logger()
        
        # Ensure event_logger is never None - create a dummy one if needed
        if self.event_logger is None:
            from utils.event_logger import EventLogger
            self.event_logger = EventLogger(debug_mode=True)
        
        # Pre-action callback system
        self.pre_action_callbacks: List[Callable[[PreActionContext], None]] = []
        # Post-action callback system
        self.post_action_callbacks: List[Callable[[PostActionContext], None]] = []
        
        # Pause callback: Called between action steps within a plan
        # Why: Allows pausing between individual steps (e.g., click, type, scroll) within
        # a single plan execution. This provides even more granular control than pausing
        # between agent-determined actions. Useful for debugging complex multi-step plans.
        # The callback should handle pause checking and blocking internally.
        self._pause_callback: Optional[Callable[[], None]] = None
    
    def set_pause_callback(self, callback: Optional[Callable[[], None]]) -> None:
        """
        Set a callback function to check for pause state between action steps.
        
        This callback is invoked between each step in a plan execution (e.g., between
        a click and a type action within the same plan). The callback should handle
        pause checking and blocking internally.
        
        Why between steps: Some plans contain multiple steps (e.g., "click field, then type").
        Pausing between steps allows inspection after each individual step completes,
        providing the most granular control possible.
        
        Args:
            callback: Function to call between action steps. Should handle pause checking
                    and blocking. Pass None to disable pause checking between steps.
        
        Example:
            >>> def check_pause():
            ...     if agent_controller.is_paused():
            ...         agent_controller._check_pause("action step")
            >>> action_executor.set_pause_callback(check_pause)
        """
        self._pause_callback = callback

    def _human_mouse_move(self, target_x: int, target_y: int, steps: int = 25):
        """
        Move mouse to target coordinates in a human-like curve (Bezier).
        """
        # Get current position
        # Playwright doesn't expose current mouse position directly easily without tracking,
        # but we can assume start from 0,0 or just jump if we don't know.
        # Better: just move from a random point near the last known position or just curve from "somewhere".
        # Since we can't easily get current pos, we'll just simulate the curve approach 
        # by assuming we are at a random offset or just doing a direct curve.
        
        # Actually, we can just use steps to smooth it out even if we jump start.
        # But to be real, let's try to get current position or just start from a reasonable place.
        # For now, we'll just implement a simple smoothing function.
        
        # A simple way to simulate human movement is to use steps with some jitter.
        # But Playwright's mouse.move has steps!
        # self.page.mouse.move(x, y, steps=25) is already linear smoothing.
        # We want non-linear (Bezier).
        
        # Let's assume we are at (0,0) if we don't know, or we can track it.
        # For this implementation, we will rely on Playwright's internal tracking if we chain moves.
        
        # To make it look real, we need a control point for the Bezier curve.
        # We can't get start_x/y easily from Playwright API (it's stateless in that regard unless we track).
        # So we will just use Playwright's built-in steps with variable speed for now, 
        # OR we can implement a "wind mouse" algorithm if we track state.
        
        # Let's stick to Playwright's steps but randomize the steps count and add jitter.
        
        # Randomize steps based on distance (if we knew it) or just random.
        actual_steps = random.randint(15, 35)
        self.page.mouse.move(target_x, target_y, steps=actual_steps)
        
        # Add a small random overshot or jitter at the end?
        # Maybe just a small random delay after move
        time.sleep(random.uniform(0.05, 0.15))

    
    def set_page(self, page: Page) -> None:
        """Update internal references when the active page changes."""
        if not page or page is self.page:
            return
        self.page = page
        if self.page_utils:
            if hasattr(self.page_utils, "set_page"):
                self.page_utils.set_page(page)
            else:
                self.page_utils.page = page
        if self.datetime_handler:
            if hasattr(self.datetime_handler, "set_page"):
                self.datetime_handler.set_page(page)
            else:
                self.datetime_handler.page = page
        if self.upload_handler:
            if hasattr(self.upload_handler, "set_page"):
                self.upload_handler.set_page(page)
            else:
                self.upload_handler.page = page
        if self.selector_utils:
            if hasattr(self.selector_utils, "set_page"):
                self.selector_utils.set_page(page)
            else:
                self.selector_utils.page = page
        if self.context_guard:
            self.context_guard.set_page(page, None)
        # Reset click tracking state for new page
        self.last_click_selector = None
        self.last_click_url = None
        self.last_click_dom_signature = None
    def register_pre_action_callback(self, callback: Callable[[PreActionContext], None]) -> None:
        """
        Register a callback to run before every action.
        
        Args:
            callback: Function that takes PreActionContext with action information
        
        Example:
            def my_callback(ctx: PreActionContext):
                if ctx.action_type == ActionType.CLICK:
                    print(f"About to click at {ctx.coordinates}")
                    # Run custom pre-action logic
            
            executor.register_pre_action_callback(my_callback)
        """
        self.pre_action_callbacks.append(callback)
        try:
            self.event_logger.system_debug(f"Registered pre-action callback: {callback.__name__}")
        except Exception:
            pass
    
    def unregister_pre_action_callback(self, callback: Callable[[PreActionContext], None]) -> None:
        """Remove a registered pre-action callback"""
        if callback in self.pre_action_callbacks:
            self.pre_action_callbacks.remove(callback)
            try:
                self.event_logger.system_debug(f"Unregistered pre-action callback: {callback.__name__}")
            except Exception:
                pass
    
    def track_scroll_event(self, reason: ScrollReason) -> None:
        """
        Track that a scroll event occurred with a reason.
        This will be included in the next post-action callback.
        
        Args:
            reason: Why the scroll occurred (ScrollReason enum value)
        """
        self.last_scroll_occurred = True
        self.last_scroll_reason = reason
    
    def clear_scroll_tracking(self) -> None:
        """Clear scroll tracking after it's been passed to callbacks"""
        self.last_scroll_occurred = False
        self.last_scroll_reason = None
    
    def register_post_action_callback(self, callback: Callable[[PostActionContext], None]) -> None:
        """
        Register a callback to run after every action.
        
        Args:
            callback: Function that takes PostActionContext with complete action information
        
        Example:
            def my_callback(ctx: PostActionContext):
                if ctx.success and ctx.action_type == ActionType.CLICK:
                    print(f"Clicked at {ctx.coordinates}")
                    # Run custom action: ctx.page.mouse.click(100, 100)
            
            executor.register_post_action_callback(my_callback)
        """
        self.post_action_callbacks.append(callback)
        try:
            self.event_logger.system_debug(f"Registered post-action callback: {callback.__name__}")
        except Exception:
            pass
    
    def unregister_post_action_callback(self, callback: Callable[[PostActionContext], None]) -> None:
        """Remove a registered callback"""
        if callback in self.post_action_callbacks:
            self.post_action_callbacks.remove(callback)
            try:
                self.event_logger.system_debug(f"Unregistered post-action callback: {callback.__name__}")
            except Exception:
                pass
    
    def _trigger_pre_action_hooks(
        self,
        action_type: ActionType,
        step: ActionStep,
        page_info: PageInfo,
        elements: PageElements,
        coordinates: Optional[Tuple[int, int]] = None,
    ) -> None:
        """Execute all registered pre-action callbacks with full context"""
        if not self.pre_action_callbacks:
            return
        
        # Get current action context
        action_id = self.action_ledger.get_current_action_id()
        action_lineage = self.action_ledger.get_lineage(action_id) if action_id else None
        
        context = PreActionContext(
            action_type=action_type,
            step=step,
            page_info=page_info,
            elements=elements,
            coordinates=coordinates,
            page=self.page,
            action_id=action_id,
            action_lineage=action_lineage,
        )
        
        for callback in self.pre_action_callbacks:
            try:
                callback(context)
            except Exception as e:
                try:
                    self.event_logger.system_error(f"Pre-action callback '{callback.__name__}' error", error=e)
                except Exception:
                    pass
    
    def _trigger_post_action_hooks(
        self,
        action_type: ActionType,
        success: bool,
        step: ActionStep,
        page_info: PageInfo,
        elements: PageElements,
        coordinates: Optional[Tuple[int, int]] = None,
        error_message: Optional[str] = None,
        action_id: Optional[str] = None,
    ) -> None:
        """Execute all registered post-action callbacks with full context"""
        if not self.post_action_callbacks:
            return
        
        # Get current action context
        # Use provided action_id or fall back to execution stack
        if action_id is None:
            action_id = self.action_ledger.get_current_action_id()
        action_lineage = self.action_ledger.get_lineage(action_id) if action_id else None
        
        # Determine scroll information
        # For scroll actions, always mark as occurred with USER_ACTION reason
        # For other actions, use tracked scroll info from automatic scrolls
        if action_type == ActionType.SCROLL:
            scroll_occurred = True
            scroll_reason = ScrollReason.USER_ACTION
        else:
            scroll_occurred = self.last_scroll_occurred
            scroll_reason = self.last_scroll_reason
        
        context = PostActionContext(
            action_type=action_type,
            success=success,
            step=step,
            page_info=page_info,
            elements=elements,
            coordinates=coordinates,
            error_message=error_message,
            page=self.page,
            action_id=action_id,
            action_lineage=action_lineage,
            scroll_occurred=scroll_occurred,
            scroll_reason=scroll_reason,
        )
        
        # Clear scroll tracking after passing to callbacks
        self.clear_scroll_tracking()
        
        for callback in self.post_action_callbacks:
            try:
                callback(context)
            except Exception as e:
                try:
                    self.event_logger.system_error(f"Post-action callback '{callback.__name__}' error", error=e)
                except Exception:
                    pass

    def execute_plan(
        self,
        plan,
        page_info: PageInfo,
        *,
        target_context_guard: Optional[str] = None,
        skip_post_guard_refinement: bool = True,
        confirm_before_interaction: bool = False,
        action_id: Optional[str] = None,
    ) -> bool:
        """
        Execute the generated plan
        
        Args:
            plan: The plan to execute
            page_info: Current page information
            target_context_guard: Guard condition for actions
            skip_post_guard_refinement: Skip refinement after guard checks
            confirm_before_interaction: Require user confirmation before actions
            action_id: Optional action ID for tracking (will use execution stack if not provided)
        
        Returns:
            True if plan executed successfully, False otherwise
        """
        self.event_logger.system_info(f"Executing plan with {len(plan.action_steps)} steps")

        # Note: Only evaluate goals AFTER actions execute, not before

        guard_text = (target_context_guard or "").strip()
        if guard_text:
            self.context_guard.reset_cache()

        self.last_failure_reason = None
        
        # Store action_id for use in action hooks
        self._current_plan_action_id = action_id

        for i, step in enumerate(plan.action_steps):
            # Check for pause between action steps
            # Why: Allows pausing between individual steps within a plan (e.g., between
            # click and type actions). This provides fine-grained control for debugging
            # complex multi-step plans.
            if self._pause_callback:
                try:
                    self._pause_callback()
                except Exception:
                    pass  # Don't let pause callback errors break execution
            
            try:
                self.event_logger.action_step(step_number=i+1, action_type=str(step.action))
            except Exception:
                pass
            
            try:
                step_success = True
                allow_refinement = True
                if guard_text and ContextGuard.is_guarded_action(step.action):
                    decision = self.context_guard.validate(
                        step=step,
                        plan=plan,
                        page_info=page_info,
                        guard_text=guard_text,
                    )
                    if not decision.passed:
                        self._handle_context_guard_failure(i, step, guard_text, decision)
                        return False
                    elif skip_post_guard_refinement:
                        allow_refinement = False
                if step.action == ActionType.CLICK:
                    step_success = self._execute_click(
                        step,
                        plan.detected_elements,
                        page_info,
                        allow_refinement=allow_refinement,
                        confirm_before_interaction=confirm_before_interaction,
                    )
                elif step.action == ActionType.TYPE:
                    step_success = self._execute_type(
                        step,
                        plan.detected_elements,
                        page_info,
                        allow_refinement=allow_refinement,
                        confirm_before_interaction=confirm_before_interaction,
                    )
                elif step.action == ActionType.SCROLL:
                    step_success = self._execute_scroll(step)
                elif step.action == ActionType.WAIT:
                    step_success = self._execute_wait(step)
                elif step.action == ActionType.PRESS:
                    step_success = self._execute_press(step)
                elif step.action == ActionType.HANDLE_UPLOAD:
                    # Get coordinates for the upload element first
                    x, y = self._get_click_coordinates(step, plan.detected_elements, page_info)
                    
                    # Record planned interaction with goal monitor and get pre-interaction evaluations
                    # Record interaction (planned -> actual)
                    self.session_tracker.record_interaction(
                        InteractionType.UPLOAD,
                        coordinates=(x, y) if x is not None and y is not None else None,
                        target_description=step.upload_file_path,
                        upload_file_path=step.upload_file_path,
                    )
                    
                    # Check for retry requests from goals immediately after evaluation
                    # Removed retry goal check - retries are handled elsewhere
                    retry_goal = None
                    if False:  # Disabled retry check
                        try:
                            self.event_logger.system_info(f"Goals have requested retry - aborting current plan execution")
                            self.event_logger.system_info(f"   {retry_goal}: Retry requested (attempt {retry_goal.retry_count}/{retry_goal.max_retries})")
                        except Exception:
                            pass
                        return False
                    
                    if confirm_before_interaction:
                        self._confirm_interaction_visual(
                            action_label="upload",
                            overlay_index=step.overlay_index,
                            selector=None,
                            coordinates=None,
                            box=None,
                            page_info=page_info,
                        )
                    self.upload_handler.handle_upload_field(step, plan.detected_elements, page_info)
                    step_success = True  # Assume success for handlers that don't return values yet
                elif step.action == ActionType.HANDLE_DATETIME:
                    # Get coordinates for the datetime element first
                    x, y = self._get_click_coordinates(step, plan.detected_elements, page_info)
                    
                    # Record planned interaction with goal monitor and get pre-interaction evaluations
                    # Record interaction (planned -> actual)
                    self.session_tracker.record_interaction(
                        InteractionType.DATETIME,
                        coordinates=(x, y) if x is not None and y is not None else None,
                        target_description=step.datetime_value or "date field",
                        datetime_value=step.datetime_value,
                    )
                    
                    # Check for retry requests from goals immediately after evaluation
                    # Removed retry goal check - retries are handled elsewhere
                    retry_goal = None
                    if False:  # Disabled retry check
                        try:
                            self.event_logger.system_info(f"Goals have requested retry - aborting current plan execution")
                            self.event_logger.system_info(f"   {retry_goal}: Retry requested (attempt {retry_goal.retry_count}/{retry_goal.max_retries})")
                        except Exception:
                            pass
                        return False
                    
                    if confirm_before_interaction:
                        self._confirm_interaction_visual(
                            action_label="datetime",
                            overlay_index=step.overlay_index,
                            selector=None,
                            coordinates=None,
                            box=None,
                            page_info=page_info,
                        )
                    self.datetime_handler.handle_datetime_field(step, plan.detected_elements, page_info)
                    step_success = True  # Assume success for handlers that don't return values yet
                    
                    # Record the datetime interaction
                    self.session_tracker.record_interaction(
                        InteractionType.DATETIME,
                        coordinates=(step.x, step.y) if step.x and step.y else None,
                        target_element_info={
                            "overlay_index": step.overlay_index,
                            "datetime_value": step.datetime_value,
                        },
                        text_input=step.datetime_value,
                        success=step_success,
                    )
                elif step.action == ActionType.OPEN:
                    step_success = self._execute_open(
                        step,
                        confirm_before_interaction=confirm_before_interaction,
                    )
                elif step.action == ActionType.BACK:
                    step_success = self._execute_back()
                elif step.action == ActionType.FORWARD:
                    step_success = self._execute_forward()
                elif step.action == ActionType.STOP:
                    step_success = self._execute_stop(step)
                else:
                    print(f"‚ö†Ô∏è Unknown action type: {step.action}")
                    continue
                
                # Check if step failed (e.g., due to retry request)
                if not step_success:
                    print(f"‚ùå Step {i+1} failed - aborting plan execution")
                    return False
                
                # Goal checking removed - keyword goals handle completion directly

                # Small delay between actions
                time.sleep(0.5)
                
            except Exception as e:
                print(f"‚ùå Error executing step {i+1}: {e}")
                self.last_failure_reason = f"Error executing step {i+1}: {e}"
                return False
        
        self.event_logger.system_info("Plan execution completed")
        return True

    def _handle_context_guard_failure(
        self,
        step_index: int,
        step: ActionStep,
        guard_text: str,
        decision: GuardDecision,
    ) -> None:
        reason = decision.reason or "Context guard validation failed"
        self.last_failure_reason = reason
        print(
            f"üõë Context guard blocked step {step_index + 1} ({step.action}). Reason: {reason}"
        )
        try:
            overlay_index = step.overlay_index
            self.session_tracker.record_interaction(
                InteractionType.CONTEXT_GUARD,
                target_element_info={
                    "overlay_index": overlay_index,
                    "action": step.action.value,
                    "guard": guard_text,
                    "cached": decision.cached,
                },
                success=False,
                error_message=reason,
            )
        except Exception:
            pass

    def _confirm_interaction_visual(
        self,
        *,
        action_label: str,
        overlay_index: Optional[int],
        selector: Optional[str],
        coordinates: Optional[Tuple[int, int]],
        box: Optional[List[int]] = None,
        page_info: Optional[PageInfo] = None,
    ) -> None:
        highlight = False
        try:
            if box and page_info and self._highlight_box(box, page_info):
                highlight = True
            elif coordinates and self._highlight_point(*coordinates):
                highlight = True
            elif overlay_index is not None and self._highlight_overlay(overlay_index):
                highlight = True
            overlay_text = f" overlay #{overlay_index}" if overlay_index is not None else ""
            input(f"\nüëÄ Confirm {action_label.upper()}{overlay_text} target. Press Enter to continue... ")
        finally:
            if highlight:
                self._clear_highlight()

    def _highlight_selector(self, selector: str) -> bool:
        script = """
        (selector) => {
            const el = document.querySelector(selector);
            if (!el) return false;
            const rect = el.getBoundingClientRect();
            const overlayId = '__codex_confirm_highlight';
            let overlay = document.getElementById(overlayId);
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = overlayId;
                overlay.style.position = 'absolute';
                overlay.style.pointerEvents = 'none';
                overlay.style.border = '3px solid #00ffae';
                overlay.style.boxShadow = '0 0 12px #00ffae';
                overlay.style.background = 'rgba(0, 255, 174, 0.18)';
                overlay.style.zIndex = 2147483647;
                document.body.appendChild(overlay);
            }
            overlay.style.left = (rect.left + window.scrollX) + 'px';
            overlay.style.top = (rect.top + window.scrollY) + 'px';
            overlay.style.width = rect.width + 'px';
            overlay.style.height = rect.height + 'px';
            return true;
        }
        """
        try:
            return bool(self.page.evaluate(script, selector))
        except Exception:
            return False

    def _highlight_overlay(self, overlay_index: int) -> bool:
        selector = f'[data-automation-overlay-index="{overlay_index}"]'
        if self._highlight_selector(selector):
            return True
        fallback_selector = f'[data-overlay-index="{overlay_index}"]'
        return self._highlight_selector(fallback_selector)

    def _highlight_box(self, box: List[int], page_info: PageInfo) -> bool:
        if not box or len(box) != 4 or not page_info:
            return False
        try:
            y_min, x_min, y_max, x_max = box
            width_px = page_info.width or page_info.ss_pixel_w or 0
            height_px = page_info.height or page_info.ss_pixel_h or 0
            if not width_px or not height_px:
                return False
            left = max(0, int(x_min / 1000.0 * width_px))
            right = max(0, int(x_max / 1000.0 * width_px))
            top = max(0, int(y_min / 1000.0 * height_px))
            bottom = max(0, int(y_max / 1000.0 * height_px))
            width = max(1, right - left)
            height = max(1, bottom - top)
            script = """
            ({ left, top, width, height }) => {
                const overlayId = '__codex_confirm_highlight';
                let overlay = document.getElementById(overlayId);
                if (!overlay) {
                    overlay = document.createElement('div');
                    overlay.id = overlayId;
                    overlay.style.position = 'absolute';
                    overlay.style.pointerEvents = 'none';
                    overlay.style.border = '3px solid #00ffae';
                    overlay.style.boxShadow = '0 0 12px #00ffae';
                    overlay.style.background = 'rgba(0, 255, 174, 0.18)';
                    overlay.style.zIndex = 2147483647;
                    document.body.appendChild(overlay);
                }
                overlay.style.left = (left + window.scrollX) + 'px';
                overlay.style.top = (top + window.scrollY) + 'px';
                overlay.style.width = width + 'px';
                overlay.style.height = height + 'px';
                return true;
            }
            """
            return bool(self.page.evaluate(script, {
                "left": left,
                "top": top,
                "width": width,
                "height": height,
            }))
        except Exception:
            return False

    def _highlight_point(self, x: int, y: int) -> bool:
        script = """
        ({x, y}) => {
            if (typeof x !== 'number' || typeof y !== 'number') return false;
            const overlayId = '__codex_confirm_highlight';
            let overlay = document.getElementById(overlayId);
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = overlayId;
                overlay.style.position = 'absolute';
                overlay.style.pointerEvents = 'none';
                overlay.style.borderRadius = '18px';
                overlay.style.zIndex = 2147483647;
                overlay.style.boxShadow = '0 0 10px #00ffae';
                overlay.style.background = 'rgba(0, 255, 174, 0.25)';
                document.body.appendChild(overlay);
            }
            const size = 36;
            overlay.style.width = overlay.style.height = size + 'px';
            overlay.style.left = (x - size / 2) + 'px';
            overlay.style.top = (y - size / 2) + 'px';
            return true;
        }
        """
        try:
            return bool(self.page.evaluate(script, {"x": x, "y": y}))
        except Exception:
            return False

    def _clear_highlight(self) -> None:
        script = """
        () => {
            const overlay = document.getElementById('__codex_confirm_highlight');
            if (overlay && overlay.remove) {
                overlay.remove();
            }
            return true;
        }
        """
        try:
            self.page.evaluate(script)
        except Exception:
            pass

    def _execute_forward(self) -> bool:
        """Navigate forward in browser history and record interaction."""
        # Capture state BEFORE navigation for accurate before_state
        before_url = ""
        before_state = None
        try:
            before_url = self.page.url
            before_state = self.session_tracker._capture_current_state()
        except Exception:
            pass
        
        try:
            self.page.go_forward()
            success = True
            error_msg = None
        except Exception as e:
            success = False
            error_msg = str(e)
            print(f"  ‚ùå Forward navigation failed: {e}")
        
        # Get URL after navigation
        after_url = before_url  # Default to before_url if navigation failed
        if success:
            try:
                after_url = self.page.url
            except Exception:
                pass
        
        # Record navigation interaction with explicit before_state
        try:
            self.session_tracker.record_interaction(
                InteractionType.NAVIGATION,
                before_state=before_state,  # Pass explicit before_state since navigation already happened
                target_element_info={"direction": "forward", "from": before_url, "to": after_url},
                success=success,
                error_message=error_msg,
            )
        except Exception:
            pass
        return success

    def _execute_click(
        self,
        step: ActionStep,
        elements: PageElements,
        page_info: PageInfo,
        *,
        allow_refinement: bool = True,
        confirm_before_interaction: bool = False,
    ) -> bool:
        """Execute a click action"""
        # Check if target element is in the filtered elements (focus context)
        if step.overlay_index is not None:
            target_found = False
            for element in elements.elements:
                if getattr(element, 'overlay_number', None) == step.overlay_index:
                    target_found = True
                    break
            
            if not target_found:
                print(f"‚ùå Target element {step.overlay_index} is not in focus context - goal failed")
                return False
        
        x, y = self._get_click_coordinates(step, elements, page_info)
        if x is None or y is None:
            raise ValueError("Could not determine click coordinates")

        box = None
        if step.overlay_index is not None and elements and getattr(elements, 'elements', None):
            for el in elements.elements:
                if getattr(el, 'overlay_number', None) == step.overlay_index and getattr(el, 'box_2d', None):
                    box = el.box_2d
                    break

        # Trigger pre-action hooks early, before any confirmations or refinements
        self._trigger_pre_action_hooks(
            action_type=ActionType.CLICK,
            step=step,
            page_info=page_info,
            elements=elements,
            coordinates=(x, y),
        )

        if confirm_before_interaction:
            self._confirm_interaction_visual(
                action_label="click",
                overlay_index=step.overlay_index,
                selector=None,
                coordinates=(x, y),
                box=box,
                page_info=page_info,
            )

        # Removed planned interaction tracking (was for goal evaluation)
        # Check for retry requests - disabled as retries are handled elsewhere
        retry_goal = None
        if False:  # Disabled retry check
            try:
                self.event_logger.system_info(f"Goals have requested retry - aborting current plan execution")
                self.event_logger.system_info(f"   {retry_goal}: Retry requested (attempt {retry_goal.retry_count}/{retry_goal.max_retries})")
            except Exception:
                pass
            # Return False to indicate plan should be regenerated
            return False
        
        # Goal system removed - pre-evaluation checks removed
        
        try:
            self.event_logger.system_debug(f"Clicking at ({x}, {y}) using mouse click")
        except Exception:
            pass

        # Capture state BEFORE performing the click (critical for accurate before_state)
        before_state = self.session_tracker._capture_current_state()

        success = False
        error_msg = None

        try:
            self._human_mouse_move(x, y)
            self.page.mouse.click(x, y)
            success = True
        except Exception as e:
            error_msg = str(e)
            if hasattr(self.event_logger, 'debug_mode') and self.event_logger.debug_mode:
                print(f"  ‚ö†Ô∏è Mouse click failed ({e})")

        if not success:
            print(f"  ‚ùå Click failed: {error_msg}")
        
        # Record actual interaction with goal monitor (pass explicit before_state since click already happened)
        self.session_tracker.record_interaction(
            InteractionType.CLICK,
            before_state=before_state,  # Pass explicit before_state captured before the click
            coordinates=(x, y),
            success=success,
            error_message=error_msg
        )
        
        # Mark element as interacted for deduplication
        if success:
            self._mark_element_as_interacted(step, elements, "click")
        
        # Trigger post-action hooks
        self._trigger_post_action_hooks(
            action_type=ActionType.CLICK,
            success=success,
            step=step,
            page_info=page_info,
            elements=elements,
            coordinates=(x, y),
            error_message=error_msg,
            action_id=getattr(self, '_current_plan_action_id', None),
        )
        
        return success

    def _clear_input_field(self, x: Optional[int], y: Optional[int]) -> None:
        """
        Clear an input field before typing to ensure previous text is removed.
        Tries multiple methods: JavaScript first, then keyboard select-all+delete.
        
        Args:
            x: X coordinate of the input field
            y: Y coordinate of the input field
        """
        if x is None or y is None:
            return
        
        try:
            # Try to clear using JavaScript first (most reliable)
            element_js = f"""
            (function() {{
                const element = document.elementFromPoint({x}, {y});
                if (element && (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA')) {{
                    element.focus();
                    element.value = '';
                    element.dispatchEvent(new Event('input', {{ bubbles: true }}));
                    element.dispatchEvent(new Event('change', {{ bubbles: true }}));
                    return true;
                }}
                return false;
            }})();
            """
            cleared = self.page.evaluate(element_js)
            if cleared:
                # Only show in debug mode
                if hasattr(self.event_logger, 'debug_mode') and self.event_logger.debug_mode:
                    print(f"  ‚úÖ Cleared field using JavaScript")
                time.sleep(0.1)
                return
        except Exception as e:
            # Only show in debug mode
            if hasattr(self.event_logger, 'debug_mode') and self.event_logger.debug_mode:
                print(f"  ‚ö†Ô∏è JavaScript clear failed, using keyboard: {e}")
        
        # Fallback: click, select all, delete
        try:
            self.page.mouse.click(x, y)
            time.sleep(0.2)
            self.page.keyboard.press('Control+a')
            time.sleep(0.1)
            self.page.keyboard.press('Delete')
            time.sleep(0.1)
            # Only show in debug mode
            if hasattr(self.event_logger, 'debug_mode') and self.event_logger.debug_mode:
                print(f"  ‚úÖ Cleared field using keyboard (Ctrl+A, Delete)")
        except Exception as e:
            # Only show in debug mode
            if hasattr(self.event_logger, 'debug_mode') and self.event_logger.debug_mode:
                print(f"  ‚ö†Ô∏è Keyboard clear failed: {e}")

    def _execute_type(
        self,
        step: ActionStep,
        elements: PageElements,
        page_info: PageInfo,
        *,
        allow_refinement: bool = True,
        confirm_before_interaction: bool = False,
    ) -> bool:
        """Execute a type action"""
        if not step.text_to_type:
            print("‚ö†Ô∏è No text specified for TYPE action")
            return False

        # Get coordinates for the element to type into
        x, y = self._get_click_coordinates(step, elements, page_info)
        box = None
        if step.overlay_index is not None and elements and getattr(elements, 'elements', None):
            for el in elements.elements:
                if getattr(el, 'overlay_number', None) == step.overlay_index and getattr(el, 'box_2d', None):
                    box = el.box_2d
                    break
        
        # Record planned interaction - removed (was for goal evaluation)
        
        # Check for retry requests from goals immediately after evaluation
        # Removed retry goal check - retries are handled elsewhere
        retry_goal = None
        # retry_goal = self.goal_monitor.check_for_retry_request()
        if retry_goal:
            try:
                self.event_logger.system_info(f"Goals have requested retry - aborting current plan execution")
                self.event_logger.system_info(f"   {retry_goal}: Retry requested (attempt {retry_goal.retry_count}/{retry_goal.max_retries})")
            except Exception:
                pass
            return False
        
        # Trigger pre-action hooks early, before any interactions
        self._trigger_pre_action_hooks(
            action_type=ActionType.TYPE,
            step=step,
            page_info=page_info,
            elements=elements,
            coordinates=(x, y) if x is not None and y is not None else None,
        )

        # Click first to focus the element
        if x is not None and y is not None:
            # Validate and clamp coordinates to viewport
            if confirm_before_interaction:
                self._confirm_interaction_visual(
                    action_label="type",
                    overlay_index=step.overlay_index,
                    selector=None,
                    coordinates=(x, y),
                    box=box,
                    page_info=page_info,
                )
            self._human_mouse_move(x, y)
            self.page.mouse.click(x, y)
            time.sleep(random.uniform(0.1, 0.3))
        
        # Capture state BEFORE performing the type action (critical for accurate before_state)
        before_state = self.session_tracker._capture_current_state()
        
        try:
            self.event_logger.system_debug(f"Typing: {step.text_to_type}")
        except Exception:
            pass
        
        try:
            # Always clear the field before typing to ensure previous text is removed
            self._clear_input_field(x, y)
            
            # Try to get element selector and use fill() or press_sequentially
            element_selector = None
            if x is not None and y is not None:
                try:
                    element_selector = self.selector_utils.get_element_selector_from_coordinates(x, y)
                    if element_selector:
                        try:
                            self.event_logger.system_debug(f"Using fill() method with selector: {element_selector}")
                        except Exception:
                            pass
                        # Use locator for more reliable filling
                        locator = self.page.locator(element_selector).first
                        # Type with random delay between keystrokes if text is short, otherwise fill
                        # Note: fill() automatically clears, but we already cleared above for consistency
                        if len(step.text_to_type) < 50:
                            locator.press_sequentially(step.text_to_type, delay=random.randint(50, 150))
                        else:
                            locator.fill(step.text_to_type)
                        success = True
                        error_msg = None
                    else:
                        raise ValueError("Could not get element selector")
                except Exception as e:
                    # Only show in debug mode
                    if hasattr(self.event_logger, 'debug_mode') and self.event_logger.debug_mode:
                        print(f"  ‚ö†Ô∏è fill() method failed, falling back to keyboard: {e}")
                    element_selector = None
            
            # Fallback to keyboard method if fill() didn't work
            if not element_selector:
                # Ensure element is focused before keyboard typing
                if x is not None and y is not None:
                    try:
                        self.page.mouse.click(x, y)
                        time.sleep(0.1)
                    except Exception:
                        pass
                # Field was already cleared above, so just type the new text
                self.page.keyboard.type(step.text_to_type, delay=50)
                success = True
                error_msg = None
        except Exception as e:
            success = False
            error_msg = str(e)
            print(f"  ‚ùå Typing failed: {e}")
        
        # Record type interaction with goal monitor (pass explicit before_state since typing already happened)
        self.session_tracker.record_interaction(
            InteractionType.TYPE,
            before_state=before_state,  # Pass explicit before_state captured before the typing
            coordinates=(x, y) if x is not None and y is not None else None,
            text_input=step.text_to_type,
            success=success,
            error_message=error_msg
        )
        
        # Mark element as interacted for deduplication
        try:
            self.event_logger.system_debug(f"Success: {success}")
        except Exception:
            pass
        if success:
            try:
                self.event_logger.system_debug(f"Marking element as interacted for deduplication: {step.overlay_index}")
            except Exception:
                pass
            self._mark_element_as_interacted(step, elements, "type")
        
        # Trigger post-action hooks
        self._trigger_post_action_hooks(
            action_type=ActionType.TYPE,
            success=success,
            step=step,
            page_info=page_info,
            elements=elements,
            coordinates=(x, y) if x is not None and y is not None else None,
            error_message=error_msg,
            action_id=getattr(self, '_current_plan_action_id', None),
        )
        
        return success

    def _get_interpreted_scroll_position(self, direction: str):
        """Get the interpreted scroll target position from active ScrollGoal"""
        try:
            # Find active ScrollGoal
            # Goal system removed - ScrollGoal removed
            scroll_goal = None
            
            if not scroll_goal:
                return None
            
            # Goal system removed - BrowserState moved to session_tracker
            if self.page_utils:
                page_info = self.page_utils.get_page_info()
            else:
                # Fallback if page_utils is not available
                page_info = Mock()
                page_info.doc_height = 2000
                page_info.doc_width = 1200
                page_info.height = 800
                page_info.width = 1200
                page_info.scroll_x = 0
                page_info.scroll_y = 0
            
            # Only show in debug mode
            if hasattr(self.event_logger, 'debug_mode') and self.event_logger.debug_mode:
                print(f"Page height: {page_info.doc_height}, Page width: {page_info.doc_width}")
            
            # Goal system removed - ScrollGoal interpretation removed
            # Scroll interpretation no longer available
            interpretation = None
            if interpretation:
                # Only show in debug mode
                if hasattr(self.event_logger, 'debug_mode') and self.event_logger.debug_mode:
                    print(f"[ActionExecutor] ScrollGoal interpreted '{scroll_goal.user_request}' as target position ({interpretation.target_x}, {interpretation.target_y}) {interpretation.direction} ({interpretation.axis})")
                return interpretation
            
            return None
            
        except Exception as e:
            # Only show in debug mode
            if hasattr(self.event_logger, 'debug_mode') and self.event_logger.debug_mode:
                print(f"[ActionExecutor] Error getting interpreted scroll position: {e}")
            return None

    def _execute_scroll(self, step: ActionStep) -> bool:
        """
        Execute a scroll action via a straightforward Playwright scroll call.

        Args:
            step: ActionStep containing scroll direction and parameters

        Returns:
            bool: True if scroll succeeded, False otherwise
        """
        direction = step.scroll_direction or "down"
        axis = "vertical"
        current_scroll_x = int(self.page.evaluate("window.pageXOffset || window.scrollX") or 0)
        current_scroll_y = int(self.page.evaluate("window.pageYOffset || window.scrollY") or 0)

        interpreted_scroll = self._get_interpreted_scroll_position(direction)
        if interpreted_scroll:
            target_x = interpreted_scroll.target_x
            target_y = interpreted_scroll.target_y
            axis = interpreted_scroll.axis
            direction = interpreted_scroll.direction
            if hasattr(self.event_logger, 'debug_mode') and self.event_logger.debug_mode:
                print(f"[ActionExecutor] Using interpreted scroll: target position ({target_x}, {target_y}) {direction} ({axis})")
        else:
            if direction == "down":
                target_x = current_scroll_x
                target_y = min(current_scroll_y + 300, 9999)
            elif direction == "up":
                target_x = current_scroll_x
                target_y = max(current_scroll_y - 300, 0)
            elif direction == "right":
                target_x = min(current_scroll_x + 300, 9999)
                target_y = current_scroll_y
                axis = "horizontal"
            else:
                target_x = max(current_scroll_x - 300, 0)
                target_y = current_scroll_y
                axis = "horizontal"
            if hasattr(self.event_logger, 'debug_mode') and self.event_logger.debug_mode:
                print(f"[ActionExecutor] Using default scroll: target position ({target_x}, {target_y}) {direction} ({axis})")
        target_x = int(target_x)
        target_y = int(target_y)

        page_info = PageInfo(
            url=self.page.url, width=1200, height=800,
            scroll_x=current_scroll_x, scroll_y=current_scroll_y,
            title=self.page.title() or "",
            dpr=1.0,
            ss_pixel_w=1200, ss_pixel_h=800, css_scale=1.0,
            doc_width=1200, doc_height=2000
        )
        elements = PageElements(elements=[])
        self._trigger_pre_action_hooks(
            action_type=ActionType.SCROLL,
            step=step,
            page_info=page_info,
            elements=elements,
            coordinates=None,
        )

        retry_goal = None
        if retry_goal:
            try:
                self.event_logger.system_info("Goals have requested retry - aborting current plan execution")
                self.event_logger.system_info(f"   {retry_goal}: Retry requested (attempt {retry_goal.retry_count}/{retry_goal.max_retries})")
            except Exception:
                pass
            return False

        if hasattr(self.event_logger, 'debug_mode') and self.event_logger.debug_mode:
            print(f"  Scrolling to position ({target_x}, {target_y}) {direction} ({axis})")

        before_state = self.session_tracker._capture_current_state()
        success = False
        error_msg = None
        try:
            scroll_amount_y = target_y - current_scroll_y
            scroll_amount_x = target_x - current_scroll_x
            if hasattr(self.event_logger, 'debug_mode') and self.event_logger.debug_mode:
                print(f"üîç [ActionExecutor] Attempting to scroll {direction} by ({scroll_amount_x}, {scroll_amount_y})px")
            self.page.evaluate(f"window.scrollBy({scroll_amount_x}, {scroll_amount_y})")
            if self.page_utils:
                actual_scroll_y = int(self.page.evaluate("window.pageYOffset || window.scrollY") or 0)
                actual_scroll_x = int(self.page.evaluate("window.pageXOffset || window.scrollX") or 0)
                self.page_utils.last_scroll_y = actual_scroll_y
                self.page_utils.last_scroll_x = actual_scroll_x
            success = True
        except Exception as exc:
            error_msg = str(exc)
            success = False
            print(f"  ‚ùå Scroll failed: {exc}")

        self.session_tracker.record_interaction(
            InteractionType.SCROLL,
            before_state=before_state,
            target_x=target_x,
            target_y=target_y,
            scroll_direction=direction,
            scroll_axis=axis,
            success=success,
            error_message=error_msg
        )

        from models import PageElements as PE, PageInfo as PI
        current_page_info = self.page_utils.get_page_info() if self.page_utils else PI(
            width=1200, height=800, scroll_x=target_x, scroll_y=target_y,
            url=self.page.url, title="", dpr=1.0,
            ss_pixel_w=1200, ss_pixel_h=800, css_scale=1.0,
            doc_width=1200, doc_height=2000
        )
        self._trigger_post_action_hooks(
            action_type=ActionType.SCROLL,
            success=success,
            step=step,
            page_info=current_page_info,
            elements=PE(elements=[]),
            coordinates=(target_x, target_y),
            error_message=error_msg,
            action_id=getattr(self, '_current_plan_action_id', None),
        )

        return success

    def _execute_wait(self, step: ActionStep) -> bool:
        """Execute a wait action"""
        wait_time = step.wait_time_ms or 500
        # Only show in debug mode
        if hasattr(self.event_logger, 'debug_mode') and self.event_logger.debug_mode:
            print(f"  Waiting {wait_time}ms")
        time.sleep(wait_time / 1000)
        return True

    def _execute_press(self, step: ActionStep) -> bool:
        """Execute a key press action"""
        if not step.keys_to_press:
            print("‚ö†Ô∏è No keys specified for PRESS action")
            return False
        
        try:
            self.event_logger.system_debug(f"Pressing keys: {step.keys_to_press}")
        except Exception:
            pass
        
        # Trigger pre-action hooks early, before any interactions
        from models import PageElements as PE, PageInfo as PI
        current_page_info = self.page_utils.get_page_info() if self.page_utils else PI(
            width=1200, height=800, scroll_x=0, scroll_y=0,
            url=self.page.url, title="", dpr=1.0,
            ss_pixel_w=1200, ss_pixel_h=800, css_scale=1.0,
            doc_width=1200, doc_height=800
        )
        self._trigger_pre_action_hooks(
            action_type=ActionType.PRESS,
            step=step,
            page_info=current_page_info,
            elements=PE(elements=[]),
            coordinates=None,
        )
        
        # Capture state BEFORE performing the press action (critical for accurate before_state)
        before_state = self.session_tracker._capture_current_state()
        
        # Record planned interaction with goal monitor
        # Removed planned interaction tracking (was for goal evaluation)
        
        # Check for retry requests from goals immediately after evaluation
        # Removed retry goal check - retries are handled elsewhere
        retry_goal = None
        # retry_goal = self.goal_monitor.check_for_retry_request()
        if retry_goal:
            try:
                self.event_logger.system_info(f"Goals have requested retry - aborting current plan execution")
                self.event_logger.system_info(f"   {retry_goal}: Retry requested (attempt {retry_goal.retry_count}/{retry_goal.max_retries})")
            except Exception:
                pass
            return False
        
        # Goal system removed - pre-evaluation checks removed
        
        try:
            # Parse and execute the key combination
            self._parse_and_press_keys(step.keys_to_press)
            success = True
            error_msg = None
        except Exception as e:
            success = False
            error_msg = str(e)
            print(f"  ‚ùå Key press failed: {e}")
        
        # Record actual interaction with goal monitor (pass explicit before_state since press already happened)
        self.session_tracker.record_interaction(
            InteractionType.PRESS,
            before_state=before_state,  # Pass explicit before_state captured before the press
            keys_pressed=step.keys_to_press,
            success=success,
            error_message=error_msg
        )
        
        # Trigger post-action hooks
        from models import PageElements as PE, PageInfo as PI
        # Get current page info for press actions
        current_page_info = self.page_utils.get_page_info() if self.page_utils else PI(
            width=1200, height=800, scroll_x=0, scroll_y=0,
            url=self.page.url, title="", dpr=1.0,
            ss_pixel_w=1200, ss_pixel_h=800, css_scale=1.0,
            doc_width=1200, doc_height=800
        )
        self._trigger_post_action_hooks(
            action_type=ActionType.PRESS,
            success=success,
            step=step,
            page_info=current_page_info,
            elements=PE(elements=[]),
            coordinates=None,
            error_message=error_msg,
            action_id=getattr(self, '_current_plan_action_id', None),
        )
        
        return success
    
    def _parse_and_press_keys(self, keys_string: str) -> None:
        """Parse a key string and execute the key press(es)"""
        # Normalize the key string
        keys_string = keys_string.lower().strip()
        
        # Handle comma-separated keys (multiple keys to press sequentially)
        if ',' in keys_string:
            keys_list = [k.strip() for k in keys_string.split(',')]
            for key in keys_list:
                self._parse_and_press_keys(key)  # Recursively handle each key
            return
        
        # Normalize common key name variations
        # Handle "arrow_down", "arrowdown", "arrow_down" -> "down"
        if keys_string.startswith('arrow'):
            # Remove "arrow" prefix and normalize
            key_part = keys_string.replace('arrow', '').replace('_', '').strip()
            if key_part in ['up', 'down', 'left', 'right']:
                keys_string = key_part
        
        # Handle common key combinations
        if '+' in keys_string:
            # Handle key combinations like "ctrl+c", "cmd+enter", etc.
            parts = keys_string.split('+')
            modifiers = parts[:-1]
            main_key = parts[-1]
            
            # Map common modifier names
            modifier_map = {
                'ctrl': 'Control',
                'control': 'Control',
                'cmd': 'Meta',
                'command': 'Meta',
                'meta': 'Meta',
                'alt': 'Alt',
                'option': 'Alt',
                'shift': 'Shift'
            }
            
            # Map common key names
            key_map = {
                'enter': 'Enter',
                'return': 'Enter',
                'tab': 'Tab',
                'space': ' ',
                'esc': 'Escape',
                'escape': 'Escape',
                'backspace': 'Backspace',
                'delete': 'Delete',
                'del': 'Delete',
                'up': 'ArrowUp',
                'down': 'ArrowDown',
                'left': 'ArrowLeft',
                'right': 'ArrowRight',
                'home': 'Home',
                'end': 'End',
                'pageup': 'PageUp',
                'pagedown': 'PageDown',
                'f1': 'F1',
                'f2': 'F2',
                'f3': 'F3',
                'f4': 'F4',
                'f5': 'F5',
                'f6': 'F6',
                'f7': 'F7',
                'f8': 'F8',
                'f9': 'F9',
                'f10': 'F10',
                'f11': 'F11',
                'f12': 'F12'
            }
            
            # Convert modifiers
            playwright_modifiers = []
            for mod in modifiers:
                playwright_mod = modifier_map.get(mod.strip())
                if playwright_mod:
                    playwright_modifiers.append(playwright_mod)
            
            # Convert main key
            playwright_key = key_map.get(main_key.strip(), main_key.strip())
            
            # Execute the key combination
            if playwright_modifiers:
                self.page.keyboard.press(f"{'+'.join(playwright_modifiers)}+{playwright_key}")
            else:
                self.page.keyboard.press(playwright_key)
        else:
            # Handle single keys
            key_map = {
                'enter': 'Enter',
                'return': 'Enter',
                'tab': 'Tab',
                'space': ' ',
                'esc': 'Escape',
                'escape': 'Escape',
                'backspace': 'Backspace',
                'delete': 'Delete',
                'del': 'Delete',
                'up': 'ArrowUp',
                'down': 'ArrowDown',
                'left': 'ArrowLeft',
                'right': 'ArrowRight',
                'home': 'Home',
                'end': 'End',
                'pageup': 'PageUp',
                'pagedown': 'PageDown',
                'f1': 'F1',
                'f2': 'F2',
                'f3': 'F3',
                'f4': 'F4',
                'f5': 'F5',
                'f6': 'F6',
                'f7': 'F7',
                'f8': 'F8',
                'f9': 'F9',
                'f10': 'F10',
                'f11': 'F11',
                'f12': 'F12'
            }
            
            playwright_key = key_map.get(keys_string, keys_string)
            self.page.keyboard.press(playwright_key)

    def _get_click_coordinates(self, step: ActionStep, elements: PageElements, page_info: PageInfo) -> Tuple[Optional[int], Optional[int]]:
        """Get the coordinates to click based on the step"""
        # Prefer explicit coordinates when provided
        if step.x is not None and step.y is not None:
            try:
                self.event_logger.action_coordinates(f"Using explicit coordinates=({int(step.x)},{int(step.y)})")
            except Exception:
                pass
            return int(step.x), int(step.y)
        # Prefer overlay index ‚Üí convert to pixel center from normalized box
        if step.overlay_index is not None:
            # First try to find by overlay number (preferred)
            for element in elements.elements:
                if element.overlay_number == step.overlay_index and element.box_2d:
                    # ADD THIS: Validate coordinates before using them
                    if len(element.box_2d) == 4:
                        y_min, x_min, y_max, x_max = element.box_2d
                        if (0 <= y_min <= 1000 and 0 <= x_min <= 1000 and 
                            0 <= y_max <= 1000 and 0 <= x_max <= 1000 and
                            y_min < y_max and x_min < x_max):
                            center_x, center_y = get_gemini_box_2d_center_pixels(
                                element.box_2d, page_info.width, page_info.height
                            )
                            if center_x > 0 or center_y > 0:
                                try:
                                    self.event_logger.action_coordinates(f"Using overlay #{step.overlay_index} center=({center_x},{center_y}) from box={element.box_2d}")
                                except Exception:
                                    pass
                                return center_x, center_y
                        else:
                            try:
                                self.event_logger.action_coordinates(f"Skipping overlay #{step.overlay_index} with invalid coordinates: {element.box_2d}")
                            except Exception:
                                pass
                            continue
                    else:
                        try:
                            self.event_logger.action_coordinates(f"Skipping overlay #{step.overlay_index} with malformed coordinates: {element.box_2d}")
                        except Exception:
                            pass
                        continue
            # Fallback to array index (legacy support)
            if 0 <= step.overlay_index < len(elements.elements):
                element = elements.elements[step.overlay_index]
                if element.box_2d:
                    center_x, center_y = get_gemini_box_2d_center_pixels(
                        element.box_2d, page_info.width, page_info.height
                    )
                    if center_x > 0 or center_y > 0:
                        try:
                            self.event_logger.action_coordinates(f"Using elements[{step.overlay_index}] center=({center_x},{center_y}) from box={element.box_2d}")
                        except Exception:
                            pass
                        return center_x, center_y

        return None, None

    def _get_simple_dom_signature(self) -> str:
        """Get a simple DOM signature for change detection (URL + element count)"""
        try:
            import hashlib
            url = self.page.url
            # Get element count as a simple DOM change indicator
            element_count = self.page.evaluate("() => document.querySelectorAll('*').length")
            sig_src = f"{url}|{element_count}"
            return hashlib.md5(sig_src.encode("utf-8")).hexdigest()
        except Exception:
            # Fallback to just URL
            try:
                import hashlib
                return hashlib.md5(self.page.url.encode("utf-8")).hexdigest()
            except Exception:
                return "unknown"
    
    def _execute_stop(self, step: ActionStep) -> bool:
        """Execute a stop action - returns True to indicate successful stop"""
        print("üõë STOP action executed - terminating automation")
        return True

    def _mark_element_as_interacted(self, step: ActionStep, elements: PageElements, interaction_type: str) -> None:
        """Mark an element as interacted with for deduplication"""
        if not self.deduper:
            print("‚ùå No deduper to mark element as interacted with")
            return
        
        # Find the target element
        recorded_interaction = False

        if step.overlay_index is not None and elements and getattr(elements, 'elements', None):
            for element in elements.elements:
                if getattr(element, 'overlay_number', None) == step.overlay_index:
                    # Convert element to dict format expected by focus manager
                    description = getattr(element, 'description', None)
                    label = getattr(element, 'element_label', None)
                    element_dict = {
                        'tagName': getattr(element, 'element_type', '') or '',
                        'text': description or label or '',
                        'textContent': description or label or '',
                        'description': description or '',
                        'element_type': getattr(element, 'element_type', ''),
                        'href': getattr(element, 'href', ''),
                        'ariaLabel': getattr(element, 'aria_label', ''),
                        'aria_label': getattr(element, 'aria_label', ''),
                        'id': getattr(element, 'id', ''),
                        'role': getattr(element, 'role', '') or getattr(element, 'element_type', ''),
                        'overlayIndex': getattr(element, 'overlay_number', None) or step.overlay_index,
                        'box2d': getattr(element, 'box_2d', None),
                        'normalizedCoords': getattr(element, 'box_2d', None),
                    }
                    self.deduper.mark_element_as_interacted(element_dict, interaction_type)
                    recorded_interaction = True
                    break

        if not recorded_interaction:
            action_value = ''
            if getattr(step, 'action', None):
                try:
                    action_value = step.action.value  # Enum value (e.g., 'click')
                except Exception:
                    action_value = str(step.action)
            text_value = step.text_to_type or action_value
            rect_data = None
            if step.x is not None and step.y is not None:
                rect_data = {
                    'x': step.x,
                    'y': step.y,
                    'width': 0,
                    'height': 0,
                }
            fallback_dict = {
                'tagName': '',
                'text': text_value,
                'textContent': text_value,
                'description': text_value,
                'element_type': action_value,
                'overlayIndex': step.overlay_index,
                'box2d': None,
                'normalizedCoords': None,
                'role': action_value,
                'rect': rect_data,
            }
            self.deduper.mark_element_as_interacted(fallback_dict, interaction_type)
            # This is expected when overlay_index references an element not in detected_elements
            # We use fallback tracking with coordinates instead
            if step.overlay_index is not None:
                print(f"‚ÑπÔ∏è Overlay index {step.overlay_index} not in detected_elements, using fallback tracking")

    def _execute_open(
        self,
        step: ActionStep,
        *,
        confirm_before_interaction: bool = False,
    ) -> bool:
        """Open a URL directly in the current tab and record navigation."""
        url = (step.url or "").strip()
        if not url:
            print("‚ùå OPEN action missing URL")
            self.session_tracker.record_interaction(
                InteractionType.NAVIGATION,
                navigation_url="",
                success=False,
                error_message="OPEN action missing URL",
            )
            return False

        # Removed planned interaction tracking (was for goal evaluation)

        # Removed retry goal check - retries are handled elsewhere
        retry_goal = None
        # retry_goal = self.goal_monitor.check_for_retry_request()
        if retry_goal:
            try:
                self.event_logger.system_info(f"Goals have requested retry - aborting current plan execution")
                self.event_logger.system_info(f"   {retry_goal}: Retry requested (attempt {retry_goal.retry_count}/{retry_goal.max_retries})")
            except Exception:
                pass
            return False

        if confirm_before_interaction:
            print("‚ÑπÔ∏è Confirmation requested for OPEN action, skipping visual confirmation (no overlay)")

        success = True
        error_message = None
        try:
            self.page.goto(url, wait_until="domcontentloaded")
        except Exception as e:
            success = False
            error_message = str(e)
            print(f"  ‚ùå Open navigation failed: {e}")

        self.session_tracker.record_interaction(
            InteractionType.NAVIGATION,
            target_element_info={"url": url},
            navigation_url=url if success else None,
            success=success,
            error_message=error_message,
        )

        return success

    def _execute_back(self) -> bool:
        """Navigate back in browser history and record interaction."""
        # Capture state BEFORE navigation for accurate before_state
        before_url = ""
        before_state = None
        try:
            before_url = self.page.url
            before_state = self.session_tracker._capture_current_state()
        except Exception:
            pass
        
        try:
            self.page.go_back()
            success = True
            error_msg = None
        except Exception as e:
            success = False
            error_msg = str(e)
            print(f"  ‚ùå Back navigation failed: {e}")
        
        # Get URL after navigation
        after_url = before_url  # Default to before_url if navigation failed
        if success:
            try:
                after_url = self.page.url
            except Exception:
                pass
        
        # Record navigation interaction with explicit before_state
        try:
            self.session_tracker.record_interaction(
                InteractionType.NAVIGATION,
                before_state=before_state,  # Pass explicit before_state since navigation already happened
                target_element_info={"direction": "back", "from": before_url, "to": after_url},
                success=success,
                error_message=error_msg,
            )
        except Exception:
            pass
        return success
