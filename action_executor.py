"""
Executes actions generated by the vision planning system.
"""
import time
from typing import Tuple, Optional, List

from playwright.sync_api import Page
from models import ActionStep, ActionType, PageElements, PageInfo
from handlers import DateTimeHandler, SelectHandler, UploadHandler
from utils import SelectorUtils
from unittest.mock import Mock
from utils.page_utils import PageUtils
from utils.context_guard import ContextGuard, GuardDecision
from vision_utils import get_gemini_box_2d_center_pixels
from goals import GoalMonitor, InteractionType, GoalStatus
from interaction_deduper import InteractionDeduper


class ActionExecutor:
    """Executes automation actions"""
    
    def __init__(self, page: Page, goal_monitor: GoalMonitor, page_utils:PageUtils=None, deduper: InteractionDeduper=None, gif_recorder=None):
        self.page = page
        self.goal_monitor = goal_monitor
        self.page_utils = page_utils
        self.deduper = deduper or InteractionDeduper()
        self.gif_recorder = gif_recorder
        self.last_failure_reason: Optional[str] = None
        
        # Initialize specialized handlers
        self.datetime_handler = DateTimeHandler(page, goal_monitor)
        self.select_handler = SelectHandler(page)
        self.upload_handler = UploadHandler(page)
        self.selector_utils = SelectorUtils(page)
        analyzer = getattr(goal_monitor, "element_analyzer", None)
        self.context_guard = ContextGuard(page, analyzer)

    def execute_plan(
        self,
        plan,
        page_info: PageInfo,
        *,
        target_context_guard: Optional[str] = None,
        skip_post_guard_refinement: bool = True,
        confirm_before_interaction: bool = False,
    ) -> bool:
        """Execute the generated plan"""
        print(f"ðŸš€ Executing plan with {len(plan.action_steps)} steps")

        # Note: Only evaluate goals AFTER actions execute, not before

        guard_text = (target_context_guard or "").strip()
        if guard_text:
            self.context_guard.reset_cache()

        self.last_failure_reason = None

        for i, step in enumerate(plan.action_steps):
            print(f"\n  Step {i+1}: {step.action}")
            
            try:
                step_success = True
                allow_refinement = True
                if guard_text and ContextGuard.is_guarded_action(step.action):
                    decision = self.context_guard.validate(
                        step=step,
                        plan=plan,
                        page_info=page_info,
                        guard_text=guard_text,
                    )
                    if not decision.passed:
                        self._handle_context_guard_failure(i, step, guard_text, decision)
                        return False
                    elif skip_post_guard_refinement:
                        allow_refinement = False
                if step.action == ActionType.CLICK:
                    step_success = self._execute_click(
                        step,
                        plan.detected_elements,
                        page_info,
                        allow_refinement=allow_refinement,
                        confirm_before_interaction=confirm_before_interaction,
                    )
                elif step.action == ActionType.TYPE:
                    step_success = self._execute_type(
                        step,
                        plan.detected_elements,
                        page_info,
                        allow_refinement=allow_refinement,
                        confirm_before_interaction=confirm_before_interaction,
                    )
                elif step.action == ActionType.SCROLL:
                    step_success = self._execute_scroll(step)
                elif step.action == ActionType.WAIT:
                    step_success = self._execute_wait(step)
                elif step.action == ActionType.PRESS:
                    step_success = self._execute_press(step)
                elif step.action == ActionType.HANDLE_SELECT:
                    if confirm_before_interaction:
                        self._confirm_interaction_visual(
                            action_label="select",
                            overlay_index=step.overlay_index,
                            selector=None,
                            coordinates=None,
                            box=None,
                            page_info=page_info,
                        )
                    self.select_handler.handle_select_field(step, plan.detected_elements, page_info)
                    step_success = True  # Assume success for handlers that don't return values yet
                elif step.action == ActionType.HANDLE_UPLOAD:
                    if confirm_before_interaction:
                        self._confirm_interaction_visual(
                            action_label="upload",
                            overlay_index=step.overlay_index,
                            selector=None,
                            coordinates=None,
                            box=None,
                            page_info=page_info,
                        )
                    self.upload_handler.handle_upload_field(step, plan.detected_elements, page_info)
                    step_success = True  # Assume success for handlers that don't return values yet
                elif step.action == ActionType.HANDLE_DATETIME:
                    if confirm_before_interaction:
                        self._confirm_interaction_visual(
                            action_label="datetime",
                            overlay_index=step.overlay_index,
                            selector=None,
                            coordinates=None,
                            box=None,
                            page_info=page_info,
                        )
                    self.datetime_handler.handle_datetime_field(step, plan.detected_elements, page_info)
                    step_success = True  # Assume success for handlers that don't return values yet
                elif step.action == ActionType.BACK:
                    step_success = self._execute_back()
                elif step.action == ActionType.FORWARD:
                    step_success = self._execute_forward()
                elif step.action == ActionType.STOP:
                    step_success = self._execute_stop(step)
                else:
                    print(f"âš ï¸ Unknown action type: {step.action}")
                    continue
                
                # Check if step failed (e.g., due to retry request)
                if not step_success:
                    print(f"âŒ Step {i+1} failed - aborting plan execution")
                    return False
                
                # Only check for goal achievement AFTER the action executes
                if self._check_goal_achieved():
                    print("âœ… Goal achieved during step execution. Ending plan early.")
                    return True

                # Small delay between actions
                time.sleep(0.5)
                
            except Exception as e:
                print(f"âŒ Error executing step {i+1}: {e}")
                self.last_failure_reason = f"Error executing step {i+1}: {e}"
                return False
        
        print("âœ… Plan execution completed")
        return True

    def _handle_context_guard_failure(
        self,
        step_index: int,
        step: ActionStep,
        guard_text: str,
        decision: GuardDecision,
    ) -> None:
        reason = decision.reason or "Context guard validation failed"
        self.last_failure_reason = reason
        print(
            f"ðŸ›‘ Context guard blocked step {step_index + 1} ({step.action}). Reason: {reason}"
        )
        try:
            overlay_index = step.overlay_index
            self.goal_monitor.record_interaction(
                InteractionType.CONTEXT_GUARD,
                target_element_info={
                    "overlay_index": overlay_index,
                    "action": step.action.value,
                    "guard": guard_text,
                    "cached": decision.cached,
                },
                success=False,
                error_message=reason,
            )
        except Exception:
            pass

    def _confirm_interaction_visual(
        self,
        *,
        action_label: str,
        overlay_index: Optional[int],
        selector: Optional[str],
        coordinates: Optional[Tuple[int, int]],
        box: Optional[List[int]] = None,
        page_info: Optional[PageInfo] = None,
    ) -> None:
        highlight = False
        try:
            if box and page_info and self._highlight_box(box, page_info):
                highlight = True
            elif coordinates and self._highlight_point(*coordinates):
                highlight = True
            elif overlay_index is not None and self._highlight_overlay(overlay_index):
                highlight = True
            overlay_text = f" overlay #{overlay_index}" if overlay_index is not None else ""
            input(f"\nðŸ‘€ Confirm {action_label.upper()}{overlay_text} target. Press Enter to continue... ")
        finally:
            if highlight:
                self._clear_highlight()

    def _highlight_selector(self, selector: str) -> bool:
        script = """
        (selector) => {
            const el = document.querySelector(selector);
            if (!el) return false;
            const rect = el.getBoundingClientRect();
            const overlayId = '__codex_confirm_highlight';
            let overlay = document.getElementById(overlayId);
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = overlayId;
                overlay.style.position = 'absolute';
                overlay.style.pointerEvents = 'none';
                overlay.style.border = '3px solid #00ffae';
                overlay.style.boxShadow = '0 0 12px #00ffae';
                overlay.style.background = 'rgba(0, 255, 174, 0.18)';
                overlay.style.zIndex = 2147483647;
                document.body.appendChild(overlay);
            }
            overlay.style.left = (rect.left + window.scrollX) + 'px';
            overlay.style.top = (rect.top + window.scrollY) + 'px';
            overlay.style.width = rect.width + 'px';
            overlay.style.height = rect.height + 'px';
            return true;
        }
        """
        try:
            return bool(self.page.evaluate(script, selector))
        except Exception:
            return False

    def _highlight_overlay(self, overlay_index: int) -> bool:
        selector = f"[data-automation-overlay-index=\"{overlay_index}\"]"
        if self._highlight_selector(selector):
            return True
        fallback_selector = f"[data-overlay-index=\"{overlay_index}\"]"
        return self._highlight_selector(fallback_selector)

    def _highlight_box(self, box: List[int], page_info: PageInfo) -> bool:
        if not box or len(box) != 4 or not page_info:
            return False
        try:
            y_min, x_min, y_max, x_max = box
            width_px = page_info.width or page_info.ss_pixel_w or 0
            height_px = page_info.height or page_info.ss_pixel_h or 0
            if not width_px or not height_px:
                return False
            left = max(0, int(x_min / 1000.0 * width_px))
            right = max(0, int(x_max / 1000.0 * width_px))
            top = max(0, int(y_min / 1000.0 * height_px))
            bottom = max(0, int(y_max / 1000.0 * height_px))
            width = max(1, right - left)
            height = max(1, bottom - top)
            script = """
            ({ left, top, width, height }) => {
                const overlayId = '__codex_confirm_highlight';
                let overlay = document.getElementById(overlayId);
                if (!overlay) {
                    overlay = document.createElement('div');
                    overlay.id = overlayId;
                    overlay.style.position = 'absolute';
                    overlay.style.pointerEvents = 'none';
                    overlay.style.border = '3px solid #00ffae';
                    overlay.style.boxShadow = '0 0 12px #00ffae';
                    overlay.style.background = 'rgba(0, 255, 174, 0.18)';
                    overlay.style.zIndex = 2147483647;
                    document.body.appendChild(overlay);
                }
                overlay.style.left = (left + window.scrollX) + 'px';
                overlay.style.top = (top + window.scrollY) + 'px';
                overlay.style.width = width + 'px';
                overlay.style.height = height + 'px';
                return true;
            }
            """
            return bool(self.page.evaluate(script, {
                "left": left,
                "top": top,
                "width": width,
                "height": height,
            }))
        except Exception:
            return False

    def _highlight_point(self, x: int, y: int) -> bool:
        script = """
        ({x, y}) => {
            if (typeof x !== 'number' || typeof y !== 'number') return false;
            const overlayId = '__codex_confirm_highlight';
            let overlay = document.getElementById(overlayId);
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = overlayId;
                overlay.style.position = 'absolute';
                overlay.style.pointerEvents = 'none';
                overlay.style.borderRadius = '18px';
                overlay.style.zIndex = 2147483647;
                overlay.style.boxShadow = '0 0 10px #00ffae';
                overlay.style.background = 'rgba(0, 255, 174, 0.25)';
                document.body.appendChild(overlay);
            }
            const size = 36;
            overlay.style.width = overlay.style.height = size + 'px';
            overlay.style.left = (x - size / 2) + 'px';
            overlay.style.top = (y - size / 2) + 'px';
            return true;
        }
        """
        try:
            return bool(self.page.evaluate(script, {"x": x, "y": y}))
        except Exception:
            return False

    def _clear_highlight(self) -> None:
        script = """
        () => {
            const overlay = document.getElementById('__codex_confirm_highlight');
            if (overlay && overlay.remove) {
                overlay.remove();
            }
            return true;
        }
        """
        try:
            self.page.evaluate(script)
        except Exception:
            pass

    def _execute_back(self) -> bool:
        """Navigate back in browser history and record interaction."""
        try:
            prev_url = self.page.url
        except Exception:
            prev_url = ""
        try:
            self.page.go_back()
            success = True
            error_msg = None
        except Exception as e:
            success = False
            error_msg = str(e)
            print(f"  âŒ Back navigation failed: {e}")
        # Record navigation interaction
        try:
            self.goal_monitor.record_interaction(
                InteractionType.NAVIGATION,
                target_element_info={"direction": "back", "from": prev_url, "to": self.page.url if success else prev_url},
                success=success,
                error_message=error_msg,
            )
        except Exception:
            pass
        return success

    def _execute_forward(self) -> bool:
        """Navigate forward in browser history and record interaction."""
        try:
            prev_url = self.page.url
        except Exception:
            prev_url = ""
        try:
            self.page.go_forward()
            success = True
            error_msg = None
        except Exception as e:
            success = False
            error_msg = str(e)
            print(f"  âŒ Forward navigation failed: {e}")
        # Record navigation interaction
        try:
            self.goal_monitor.record_interaction(
                InteractionType.NAVIGATION,
                target_element_info={"direction": "forward", "from": prev_url, "to": self.page.url if success else prev_url},
                success=success,
                error_message=error_msg,
            )
        except Exception:
            pass
        return success

    def _execute_click(
        self,
        step: ActionStep,
        elements: PageElements,
        page_info: PageInfo,
        *,
        allow_refinement: bool = True,
        confirm_before_interaction: bool = False,
    ) -> bool:
        """Execute a click action"""
        # Check if target element is in the filtered elements (focus context)
        if step.overlay_index is not None:
            target_found = False
            for element in elements.elements:
                if getattr(element, 'overlay_number', None) == step.overlay_index:
                    target_found = True
                    break
            
            if not target_found:
                print(f"âŒ Target element {step.overlay_index} is not in focus context - goal failed")
                return False
        
        x, y = self._get_click_coordinates(step, elements, page_info)
        if x is None or y is None:
            raise ValueError("Could not determine click coordinates")

        box = None
        if step.overlay_index is not None and elements and getattr(elements, 'elements', None):
            for el in elements.elements:
                if getattr(el, 'overlay_number', None) == step.overlay_index and getattr(el, 'box_2d', None):
                    box = el.box_2d
                    break

        if confirm_before_interaction:
            self._confirm_interaction_visual(
                action_label="click",
                overlay_index=step.overlay_index,
                selector=None,
                coordinates=(x, y),
                box=box,
                page_info=page_info,
            )

        target_selector = None
        if allow_refinement:
            try:
                rx, ry, target_selector = self._resolve_click_target(x, y, page_info, normalized_box=box)
                if rx is not None and ry is not None and (rx != x or ry != y):
                    print(f"  Adjusted click target to ({rx}, {ry}) from ({x}, {y}) for clickable element")
                    x, y = rx, ry
            except Exception:
                target_selector = None
        else:
            try:
                _rx, _ry, target_selector = self._resolve_click_target(x, y, page_info, normalized_box=box)
            except Exception:
                target_selector = None

        pre_evaluations = self.goal_monitor.record_planned_interaction(
            InteractionType.CLICK,
            coordinates=(x, y),
            target_selector=target_selector,
        )
        
        # Check for retry requests from goals immediately after evaluation
        retry_goal = self.goal_monitor.check_for_retry_request()
        if retry_goal:
            print("ðŸ”„ Goals have requested retry - aborting current plan execution")
            print(f"   ðŸ”„ {retry_goal}: Retry requested (attempt {retry_goal.retry_count}/{retry_goal.max_retries})")
            # Return False to indicate plan should be regenerated
            return False
        
        # Check if the goal was achieved before the click (informational only)
        if pre_evaluations.status == GoalStatus.ACHIEVED:
            print("ðŸŽ¯ Goal achieved before click (pre-eval)! Proceeding with click as requested.")
            print(f"   âœ… {pre_evaluations.reasoning}")
        elif pre_evaluations.status == GoalStatus.FAILED:
            print("âš ï¸ Goal evaluation suggests this click may not achieve the target:")
            print(f"   âŒ {pre_evaluations.reasoning}")
            # Continue with click anyway - the user's plan should be executed
        
        # print(f"Elements: {elements.model_dump_json()}")
        # print(f"Step: {step.model_dump_json()}")
        print(f"  Clicking at ({x}, {y})")
        
        # Record interaction for GIF if recorder is available
        if self.gif_recorder:
            element_box = None
            if step.overlay_index is not None and elements and getattr(elements, 'elements', None):
                for el in elements.elements:
                    if getattr(el, 'overlay_number', None) == step.overlay_index and getattr(el, 'box_2d', None):
                        # Convert normalized coordinates to pixel coordinates
                        from vision_utils import get_gemini_box_2d_center_pixels
                        center_x, center_y = get_gemini_box_2d_center_pixels(el.box_2d, page_info.width, page_info.height)
                        # Convert to pixel box coordinates
                        y_min, x_min, y_max, x_max = el.box_2d
                        element_box = (
                            int(x_min / 1000.0 * page_info.width),
                            int(y_min / 1000.0 * page_info.height),
                            int(x_max / 1000.0 * page_info.width),
                            int(y_max / 1000.0 * page_info.height)
                        )
                        break
            
            self.gif_recorder.record_interaction(
                interaction_type="click",
                coordinates=(x, y),
                element_box=element_box,
                action_description=f"Click on element at ({x}, {y})"
            )
        
        try:
            self.page.mouse.click(x, y)
            success = True
            error_msg = None
        except Exception as e:
            success = False
            error_msg = str(e)
            print(f"  âŒ Click failed: {e}")
        
        # Record actual interaction with goal monitor
        self.goal_monitor.record_interaction(
            InteractionType.CLICK,
            coordinates=(x, y),
            success=success,
            error_message=error_msg
        )
        
        # Mark element as interacted for deduplication
        if success:
            self._mark_element_as_interacted(step, elements, "click")
        
        return success

    def _execute_type(
        self,
        step: ActionStep,
        elements: PageElements,
        page_info: PageInfo,
        *,
        allow_refinement: bool = True,
        confirm_before_interaction: bool = False,
    ) -> bool:
        """Execute a type action"""
        if not step.text_to_type:
            print("âš ï¸ No text specified for TYPE action")
            return False

        # Click first to focus the element
        x, y = self._get_click_coordinates(step, elements, page_info)
        box = None
        if x is not None and y is not None:
            # Validate and clamp coordinates to viewport
            # x, y = validate_and_clamp_coordinates(x, y, page_info.width, page_info.height)
            # Refine to a truly focusable/clickable target before clicking to focus
            if allow_refinement:
                try:
                    if step.overlay_index is not None and elements and getattr(elements, 'elements', None):
                        for el in elements.elements:
                            if getattr(el, 'overlay_number', None) == step.overlay_index and getattr(el, 'box_2d', None):
                                box = el.box_2d
                                break
                    rx, ry = self._refine_click_coordinates(x, y, page_info, normalized_box=box)
                    if rx is not None and ry is not None:
                        x, y = rx, ry
                except Exception:
                    pass
            if confirm_before_interaction:
                self._confirm_interaction_visual(
                    action_label="type",
                    overlay_index=step.overlay_index,
                    selector=None,
                    coordinates=(x, y) if x is not None and y is not None else None,
                    box=box,
                    page_info=page_info,
                )
            self.page.mouse.click(x, y)
            time.sleep(0.2)
        
        print(f"  Typing: {step.text_to_type}")
        
        # Record interaction for GIF if recorder is available
        if self.gif_recorder:
            element_box = None
            if step.overlay_index is not None and elements and getattr(elements, 'elements', None):
                for el in elements.elements:
                    if getattr(el, 'overlay_number', None) == step.overlay_index and getattr(el, 'box_2d', None):
                        # Convert normalized coordinates to pixel coordinates
                        y_min, x_min, y_max, x_max = el.box_2d
                        element_box = (
                            int(x_min / 1000.0 * page_info.width),
                            int(y_min / 1000.0 * page_info.height),
                            int(x_max / 1000.0 * page_info.width),
                            int(y_max / 1000.0 * page_info.height)
                        )
                        break
            
            self.gif_recorder.record_interaction(
                interaction_type="type",
                coordinates=(x, y) if x is not None and y is not None else None,
                element_box=element_box,
                action_description=f"Type '{step.text_to_type}'",
                text_input=step.text_to_type
            )
        
        try:
            # Try to clear existing text first (select-all then delete)
            try:
                self.page.keyboard.press('Meta+a')  # macOS
            except Exception:
                pass
            try:
                self.page.keyboard.press('Control+a')  # Windows/Linux
            except Exception:
                pass
            try:
                self.page.keyboard.press('Delete')
            except Exception:
                pass
            self.page.keyboard.type(step.text_to_type, delay=50)
            success = True
            error_msg = None
        except Exception as e:
            success = False
            error_msg = str(e)
            print(f"  âŒ Typing failed: {e}")
        
        # Record type interaction with goal monitor
        self.goal_monitor.record_interaction(
            InteractionType.TYPE,
            coordinates=(x, y) if x is not None and y is not None else None,
            text_input=step.text_to_type,
            success=success,
            error_message=error_msg
        )
        
        # Mark element as interacted for deduplication
        print("Success: ", success)
        if success:
            print(f"Marking element as interacted for deduplication: {step.overlay_index}")
            self._mark_element_as_interacted(step, elements, "type")
        
        return success

    def _get_interpreted_scroll_position(self, direction: str):
        """Get the interpreted scroll target position from active ScrollGoal"""
        try:
            # Find active ScrollGoal
            from goals import ScrollGoal
            scroll_goal = self.goal_monitor.active_goal if isinstance(self.goal_monitor.active_goal, ScrollGoal) else None
            
            if not scroll_goal:
                return None
            
            # Create a basic context for interpretation
            from goals.base import GoalContext, BrowserState
            if self.page_utils:
                page_info = self.page_utils.get_page_info()
            else:
                # Fallback if page_utils is not available
                page_info = Mock()
                page_info.doc_height = 2000
                page_info.doc_width = 1200
                page_info.height = 800
                page_info.width = 1200
                page_info.scroll_x = 0
                page_info.scroll_y = 0
            
            # Get current scroll position
            current_scroll_x = self.page.evaluate("window.pageXOffset || window.scrollX") or 0
            current_scroll_y = self.page.evaluate("window.pageYOffset || window.scrollY") or 0
            
            # Create browser state
            browser_state = BrowserState(
                timestamp=0,
                url=page_info.url,
                title=page_info.title,
                page_height=page_info.doc_height,
                page_width=page_info.doc_width,
                scroll_x=current_scroll_x,
                scroll_y=current_scroll_y
            )
            
            print(f"Page height: {page_info.doc_height}, Page width: {page_info.doc_width}")
            
            # Create goal context
            context = GoalContext(
                initial_state=browser_state,
                current_state=browser_state,
            )
            
            # Get interpreted scroll from ScrollGoal
            interpretation = scroll_goal.interpret_request(context)
            if interpretation:
                print(f"[ActionExecutor] ScrollGoal interpreted '{scroll_goal.user_request}' as target position ({interpretation.target_x}, {interpretation.target_y}) {interpretation.direction} ({interpretation.axis})")
                return interpretation
            
            return None
            
        except Exception as e:
            print(f"[ActionExecutor] Error getting interpreted scroll position: {e}")
            return None

    def _execute_scroll(self, step: ActionStep) -> bool:
        """Execute a scroll action"""
        direction = step.scroll_direction or "down"
        axis = "vertical"  # Default to vertical
        
        # Get current scroll position
        current_scroll_x = self.page.evaluate("window.pageXOffset || window.scrollX") or 0
        current_scroll_y = self.page.evaluate("window.pageYOffset || window.scrollY") or 0
        
        # Try to get the interpreted scroll position from ScrollGoal
        interpreted_scroll = self._get_interpreted_scroll_position(direction)
        if interpreted_scroll:
            target_x = interpreted_scroll.target_x
            target_y = interpreted_scroll.target_y
            axis = interpreted_scroll.axis
            direction = interpreted_scroll.direction
            print(f"[ActionExecutor] Using interpreted scroll: target position ({target_x}, {target_y}) {direction} ({axis})")
        else:
            # Fallback to default scroll behavior
            if direction == "down":
                target_x = current_scroll_x
                target_y = min(current_scroll_y + 300, 9999)  # Default 300px down
            elif direction == "up":
                target_x = current_scroll_x
                target_y = max(current_scroll_y - 300, 0)  # Default 300px up
            elif direction == "right":
                target_x = min(current_scroll_x + 300, 9999)  # Default 300px right
                target_y = current_scroll_y
                axis = "horizontal"
            else:  # left
                target_x = max(current_scroll_x - 300, 0)  # Default 300px left
                target_y = current_scroll_y
                axis = "horizontal"
            print(f"[ActionExecutor] Using default scroll: target position ({target_x}, {target_y}) {direction} ({axis})")
        
        # Record planned interaction with goal monitor and get pre-interaction evaluations
        pre_evaluations = self.goal_monitor.record_planned_interaction(
            InteractionType.SCROLL,
            target_x=target_x,
            target_y=target_y,
            scroll_direction=direction,
            scroll_axis=axis
        )
        
        # Check for retry requests from the goal immediately after evaluation
        retry_goal = self.goal_monitor.check_for_retry_request()
        if retry_goal:
            print("ðŸ”„ Goals have requested retry - aborting current plan execution")
            print(f"   ðŸ”„ {retry_goal}: Retry requested (attempt {retry_goal.retry_count}/{retry_goal.max_retries})")
            # Return False to indicate plan should be regenerated
            return False
        
        # Check if the goal was achieved before the scroll (informational only)
        if pre_evaluations.status == GoalStatus.ACHIEVED:
            print("ðŸŽ¯ Goal achieved before scroll (pre-eval)! Proceeding with scroll as requested.")
            print(f"   âœ… {pre_evaluations.reasoning}")
        elif pre_evaluations.status == GoalStatus.FAILED:
            print("âš ï¸ Goal evaluation suggests this scroll may not achieve the target:")
            print(f"   âŒ {pre_evaluations.reasoning}")
            # Continue with scroll anyway - the user's plan should be executed
        
        print(f"  Scrolling to position ({target_x}, {target_y}) {direction} ({axis})")
        
        # Record interaction for GIF if recorder is available
        if self.gif_recorder:
            self.gif_recorder.record_interaction(
                interaction_type="scroll",
                coordinates=None,
                element_box=None,
                action_description=f"Scroll {direction} to ({target_x}, {target_y})"
            )
        
        try:
            self.page.evaluate(f"window.scrollTo({target_x}, {target_y})")
            success = True
            error_msg = None
        except Exception as e:
            success = False
            error_msg = str(e)
            print(f"  âŒ Scroll failed: {e}")
        
        # Record actual interaction with goal monitor
        self.goal_monitor.record_interaction(
            InteractionType.SCROLL,
            target_x=target_x,
            target_y=target_y,
            scroll_direction=direction,
            scroll_axis=axis,
            success=success,
            error_message=error_msg
        )
        
        return success

    def _execute_wait(self, step: ActionStep) -> bool:
        """Execute a wait action"""
        wait_time = step.wait_time_ms or 500
        print(f"  Waiting {wait_time}ms")
        time.sleep(wait_time / 1000)
        return True

    def _execute_press(self, step: ActionStep) -> bool:
        """Execute a key press action"""
        if not step.keys_to_press:
            print("âš ï¸ No keys specified for PRESS action")
            return False
        
        print(f"  Pressing keys: {step.keys_to_press}")
        
        # Record interaction for GIF if recorder is available
        if self.gif_recorder:
            self.gif_recorder.record_interaction(
                interaction_type="press",
                coordinates=None,
                element_box=None,
                action_description=f"Press keys: {step.keys_to_press}",
                keys_pressed=step.keys_to_press
            )
        
        # Record planned interaction with goal monitor
        pre_evaluations = self.goal_monitor.record_planned_interaction(
            InteractionType.PRESS,
            keys_to_press=step.keys_to_press
        )
        
        # Check for retry requests from goals immediately after evaluation
        retry_goal = self.goal_monitor.check_for_retry_request()
        if retry_goal:
            print("ðŸ”„ Goals have requested retry - aborting current plan execution")
            print(f"   ðŸ”„ {retry_goal}: Retry requested (attempt {retry_goal.retry_count}/{retry_goal.max_retries})")
            return False
        
        # Check if the goal was achieved before the press (informational only)
        if pre_evaluations.status == GoalStatus.ACHIEVED:
            print("ðŸŽ¯ Goal achieved before key press (pre-eval)! Proceeding with press as requested.")
            print(f"   âœ… {pre_evaluations.reasoning}")
        elif pre_evaluations.status == GoalStatus.FAILED:
            print("âš ï¸ Goal evaluation suggests this key press may not achieve the target:")
            print(f"   âŒ {pre_evaluations.reasoning}")
        
        try:
            # Parse and execute the key combination
            self._parse_and_press_keys(step.keys_to_press)
            success = True
            error_msg = None
        except Exception as e:
            success = False
            error_msg = str(e)
            print(f"  âŒ Key press failed: {e}")
        
        # Record actual interaction with goal monitor
        self.goal_monitor.record_interaction(
            InteractionType.PRESS,
            keys_pressed=step.keys_to_press,
            success=success,
            error_message=error_msg
        )
        
        return success
    
    def _parse_and_press_keys(self, keys_string: str) -> None:
        """Parse a key string and execute the key press(es)"""
        # Normalize the key string
        keys_string = keys_string.lower().strip()
        
        # Handle common key combinations
        if '+' in keys_string:
            # Handle key combinations like "ctrl+c", "cmd+enter", etc.
            parts = keys_string.split('+')
            modifiers = parts[:-1]
            main_key = parts[-1]
            
            # Map common modifier names
            modifier_map = {
                'ctrl': 'Control',
                'control': 'Control',
                'cmd': 'Meta',
                'command': 'Meta',
                'meta': 'Meta',
                'alt': 'Alt',
                'option': 'Alt',
                'shift': 'Shift'
            }
            
            # Map common key names
            key_map = {
                'enter': 'Enter',
                'return': 'Enter',
                'tab': 'Tab',
                'space': ' ',
                'esc': 'Escape',
                'escape': 'Escape',
                'backspace': 'Backspace',
                'delete': 'Delete',
                'del': 'Delete',
                'up': 'ArrowUp',
                'down': 'ArrowDown',
                'left': 'ArrowLeft',
                'right': 'ArrowRight',
                'home': 'Home',
                'end': 'End',
                'pageup': 'PageUp',
                'pagedown': 'PageDown',
                'f1': 'F1',
                'f2': 'F2',
                'f3': 'F3',
                'f4': 'F4',
                'f5': 'F5',
                'f6': 'F6',
                'f7': 'F7',
                'f8': 'F8',
                'f9': 'F9',
                'f10': 'F10',
                'f11': 'F11',
                'f12': 'F12'
            }
            
            # Convert modifiers
            playwright_modifiers = []
            for mod in modifiers:
                playwright_mod = modifier_map.get(mod.strip())
                if playwright_mod:
                    playwright_modifiers.append(playwright_mod)
            
            # Convert main key
            playwright_key = key_map.get(main_key.strip(), main_key.strip())
            
            # Execute the key combination
            if playwright_modifiers:
                self.page.keyboard.press(f"{'+'.join(playwright_modifiers)}+{playwright_key}")
            else:
                self.page.keyboard.press(playwright_key)
        else:
            # Handle single keys
            key_map = {
                'enter': 'Enter',
                'return': 'Enter',
                'tab': 'Tab',
                'space': ' ',
                'esc': 'Escape',
                'escape': 'Escape',
                'backspace': 'Backspace',
                'delete': 'Delete',
                'del': 'Delete',
                'up': 'ArrowUp',
                'down': 'ArrowDown',
                'left': 'ArrowLeft',
                'right': 'ArrowRight',
                'home': 'Home',
                'end': 'End',
                'pageup': 'PageUp',
                'pagedown': 'PageDown',
                'f1': 'F1',
                'f2': 'F2',
                'f3': 'F3',
                'f4': 'F4',
                'f5': 'F5',
                'f6': 'F6',
                'f7': 'F7',
                'f8': 'F8',
                'f9': 'F9',
                'f10': 'F10',
                'f11': 'F11',
                'f12': 'F12'
            }
            
            playwright_key = key_map.get(keys_string, keys_string)
            self.page.keyboard.press(playwright_key)

    def _get_click_coordinates(self, step: ActionStep, elements: PageElements, page_info: PageInfo) -> Tuple[Optional[int], Optional[int]]:
        """Get the coordinates to click based on the step"""
        # Prefer overlay index â†’ convert to pixel center from normalized box
        if step.overlay_index is not None:
            # First try to find by overlay number (preferred)
            for element in elements.elements:
                if element.overlay_number == step.overlay_index and element.box_2d:
                    center_x, center_y = get_gemini_box_2d_center_pixels(
                        element.box_2d, page_info.width, page_info.height
                    )
                    if center_x > 0 or center_y > 0:
                        print(f"[Exec][coords] Using overlay #{step.overlay_index} center=({center_x},{center_y}) from box={element.box_2d}")
                        return center_x, center_y
            # Fallback to array index (legacy support)
            if 0 <= step.overlay_index < len(elements.elements):
                element = elements.elements[step.overlay_index]
                if element.box_2d:
                    center_x, center_y = get_gemini_box_2d_center_pixels(
                        element.box_2d, page_info.width, page_info.height
                    )
                    if center_x > 0 or center_y > 0:
                        print(f"[Exec][coords] Using elements[{step.overlay_index}] center=({center_x},{center_y}) from box={element.box_2d}")
                        return center_x, center_y

        # Fallback: use raw coordinates if provided
        if step.x is not None and step.y is not None:
            print(f"[Exec][coords] Using explicit coordinates=({int(step.x)},{int(step.y)})")
            return int(step.x), int(step.y)
        
        return None, None

    def _find_clickable_point_from_overlay(self, overlay_index: int) -> Tuple[Optional[int], Optional[int]]:
        """Given an overlay index, try to find a clickable descendant within that element and return its center.

        Uses the 'data-automation-overlay-index' attribute set during overlay creation to locate the element.
        """
        js = r"""
        (idx) => {
          const sel = `[data-automation-overlay-index="${idx}"]`;
          const root = document.querySelector(sel);
          if (!root) return null;
          const cand = root.querySelector('a,button,[role="link"],[role="button"],input,select,textarea') || root;
          const r = cand.getBoundingClientRect();
          const cx = Math.round(r.left + r.width/2);
          const cy = Math.round(r.top + r.height/2);
          return {x: cx, y: cy};
        }
        """
        try:
            res = self.page.evaluate(js, overlay_index)
            if isinstance(res, dict) and 'x' in res and 'y' in res:
                return int(res['x']), int(res['y'])
        except Exception:
            pass
        return None, None

    def _refine_click_coordinates(self, x: int, y: int, page_info: PageInfo, normalized_box=None) -> Tuple[Optional[int], Optional[int]]:
        """Refine coordinates to the center of the nearest clickable element at/within the region.

        - First try the exact point (x,y): ascend to a clickable ancestor.
        - If not found, sample multiple points within the element box (if provided) or around (x,y).
        - Clickable definition: anchor/button/input/select/textarea or role=button/link, onclick, tabindex, pointer cursor.
        """
        js = r"""
        (arg) => {
          const x = arg && arg.x !== undefined ? arg.x : 0;
          const y = arg && arg.y !== undefined ? arg.y : 0;
          const region = arg ? arg.region : null;
          function isClickable(el) {
            if (!el || el.nodeType !== 1) return false;
            const tag = el.tagName.toLowerCase();
            if (["a","button","input","select","textarea","summary","label"].includes(tag)) return true;
            const role = el.getAttribute && el.getAttribute('role');
            if (role && ["button","link","tab","menuitem","option","combobox"].includes(role.toLowerCase())) return true;
            if (el.onclick || el.getAttribute && el.getAttribute('onclick')) return true;
            if (el.hasAttribute && el.hasAttribute('tabindex') && el.getAttribute('tabindex') !== '-1') return true;
            const style = window.getComputedStyle(el);
            if (style && style.cursor === 'pointer') return true;
            return false;
          }

          function toPoint(el){
            const r = el.getBoundingClientRect();
            return {x: Math.round(r.left + r.width/2), y: Math.round(r.top + r.height/2), tag: el.tagName.toLowerCase()};
          }

          function findClickableFromPoint(px, py){
            let el = document.elementFromPoint(px, py);
            // Ascend to clickable ancestor
            let cur = el;
            while (cur && cur !== document.body && !isClickable(cur)) cur = cur.parentElement;
            if (cur && isClickable(cur)) return toPoint(cur);
            // Try clickable descendant from the element
            if (el && el.querySelector) {
              const cand = el.querySelector('a,button,input,select,textarea,[role="button"],[role="link"],[onclick],[tabindex]');
              if (cand) return toPoint(cand);
            }
            // Try closest anchor for common SERP structures (h3 within a)
            if (el && el.closest) {
              const link = el.closest('a,[role="link"]');
              if (link) return toPoint(link);
            }
            return null;
          }

          function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }

          // Region rectangle in viewport pixels
          const vw = window.innerWidth, vh = window.innerHeight;
          let xMin, yMin, xMax, yMax;
          if (region && Array.isArray(region) && region.length === 4){
            yMin = region[0]/1000*vh; xMin = region[1]/1000*vw; yMax = region[2]/1000*vh; xMax = region[3]/1000*vw;
          } else {
            const w = 220, h = 140; // default search window around the point
            xMin = x - w/2; xMax = x + w/2; yMin = y - h/2; yMax = y + h/2;
          }
          xMin = clamp(Math.round(xMin), 0, vw-1); xMax = clamp(Math.round(xMax), 0, vw-1);
          yMin = clamp(Math.round(yMin), 0, vh-1); yMax = clamp(Math.round(yMax), 0, vh-1);
          const cx = Math.round((xMin + xMax)/2), cy = Math.round((yMin + yMax)/2);

          // Build sample points (center, edges, corners)
          const pts = [
            [cx, cy],
            [xMin + 4, cy], [xMax - 4, cy],
            [cx, yMin + 4], [cx, yMax - 4],
            [xMin + 8, yMin + 8], [xMax - 8, yMin + 8],
            [xMin + 8, yMax - 8], [xMax - 8, yMax - 8]
          ];
          for (const [sx, sy] of pts){
            const p = findClickableFromPoint(sx, sy);
            if (p) return p;
          }

          // Fallback: search clickable elements intersecting the region
          function overlapArea(r1, r2){
            const x1 = Math.max(r1.left, r2.left), y1 = Math.max(r1.top, r2.top);
            const x2 = Math.min(r1.right, r2.right), y2 = Math.min(r1.bottom, r2.bottom);
            const w = Math.max(0, x2 - x1), h = Math.max(0, y2 - y1);
            return w * h;
          }
          const regionRect = {left: xMin, top: yMin, right: xMax, bottom: yMax};
          const candSel = 'a,button,[role="link"],[role="button"],input,select,textarea';
          const cands = Array.from(document.querySelectorAll(candSel))
            .filter(el => {
              const st = getComputedStyle(el);
              if (st.display === 'none' || st.visibility === 'hidden' || st.pointerEvents === 'none') return false;
              const r = el.getBoundingClientRect();
              if (r.width < 4 || r.height < 4) return false;
              return true;
            });
          let best = null, bestScore = -1;
          for (const el of cands){
            const r = el.getBoundingClientRect();
            const ia = overlapArea(r, regionRect);
            const centerDist = Math.hypot((r.left + r.width/2) - cx, (r.top + r.height/2) - cy);
            // Score: prioritize overlap, break ties by closeness to center
            const score = ia > 0 ? ia - centerDist : -centerDist;
            if (score > bestScore){ bestScore = score; best = el; }
          }
          if (best) return toPoint(best);

          return null;
        }
        """

        try:
            result = self.page.evaluate(js, {"x": x, "y": y, "region": normalized_box})
            if result and isinstance(result, dict) and 'x' in result and 'y' in result:
                rx, ry = int(result['x']), int(result['y'])
                # Clamp to viewport
                rx = max(0, min(page_info.width - 1, rx))
                ry = max(0, min(page_info.height - 1, ry))
                try:
                    tag = result.get('tag')
                    if tag:
                        print(f"  Refinement found clickable <{tag}> at ({rx}, {ry})")
                except Exception:
                    pass
                return rx, ry
        except Exception:
            pass
        return x, y

    def _resolve_click_target(self, x: int, y: int, page_info: PageInfo, normalized_box=None) -> Tuple[Optional[int], Optional[int], Optional[str]]:
        """Resolve a clickable element near a point/region and mark it with a temporary selector.

        Returns (rx, ry, selector) where selector is a CSS selector to the marked element.
        """
        import random
        token = f"auto-{int(time.time()*1000)}-{random.randint(1000,9999)}"
        js = r"""
        ({ x, y, region, token }) => {
          function isClickable(el) {
            if (!el || el.nodeType !== 1) return false;
            const tag = el.tagName.toLowerCase();
            if (["a","button","input","select","textarea","summary","label"].includes(tag)) return true;
            const role = el.getAttribute && el.getAttribute('role');
            if (role && ["button","link","tab","menuitem","option","combobox"].includes(role.toLowerCase())) return true;
            if (el.onclick || el.getAttribute && el.getAttribute('onclick')) return true;
            if (el.hasAttribute && el.hasAttribute('tabindex') && el.getAttribute('tabindex') !== '-1') return true;
            const style = window.getComputedStyle(el);
            if (style && style.cursor === 'pointer') return true;
            return false;
          }
          function toPoint(el){
            const r = el.getBoundingClientRect();
            return {x: Math.round(r.left + r.width/2), y: Math.round(r.top + r.height/2), tag: el.tagName.toLowerCase()};
          }
          function findClickableFromPoint(px, py){
            let el = document.elementFromPoint(px, py);
            let cur = el;
            while (cur && cur !== document.body && !isClickable(cur)) cur = cur.parentElement;
            if (cur && isClickable(cur)) return cur;
            if (el && el.querySelector) {
              const cand = el.querySelector('a,button,input,select,textarea,[role="button"],[role="link"],[onclick],[tabindex]');
              if (cand) return cand;
            }
            if (el && el.closest) {
              const link = el.closest('a,[role="link"]');
              if (link) return link;
            }
            return null;
          }
          function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }
          const vw = window.innerWidth, vh = window.innerHeight;
          let xMin, yMin, xMax, yMax;
          if (region && Array.isArray(region) && region.length === 4){
            yMin = region[0]/1000*vh; xMin = region[1]/1000*vw; yMax = region[2]/1000*vh; xMax = region[3]/1000*vw;
          } else {
            const w = 220, h = 140;
            xMin = x - w/2; xMax = x + w/2; yMin = y - h/2; yMax = y + h/2;
          }
          xMin = clamp(Math.round(xMin), 0, vw-1); xMax = clamp(Math.round(xMax), 0, vw-1);
          yMin = clamp(Math.round(yMin), 0, vh-1); yMax = clamp(Math.round(yMax), 0, vh-1);
          const cx = Math.round((xMin + xMax)/2), cy = Math.round((yMin + yMax)/2);
          const pts = [ [cx, cy], [xMin+4, cy], [xMax-4, cy], [cx, yMin+4], [cx, yMax-4], [xMin+8, yMin+8], [xMax-8, yMin+8], [xMin+8, yMax-8], [xMax-8, yMax-8] ];
          let target = null;
          for (const [sx, sy] of pts){
            const cand = findClickableFromPoint(sx, sy);
            if (cand){ target = cand; break; }
          }
          if (!target){
            // Fallback: search clickable elements overlapping the region
            const regionRect = {left: xMin, top: yMin, right: xMax, bottom: yMax};
            function overlapArea(r1, r2){
              const x1 = Math.max(r1.left, r2.left), y1 = Math.max(r1.top, r2.top);
              const x2 = Math.min(r1.right, r2.right), y2 = Math.min(r1.bottom, r2.bottom);
              const w = Math.max(0, x2 - x1), h = Math.max(0, y2 - y1);
              return w * h;
            }
            const candSel = 'a,button,[role="link"],[role="button"],input,select,textarea';
            let best = null, bestScore = -1;
            for (const el of document.querySelectorAll(candSel)){
              const st = getComputedStyle(el);
              if (st.display === 'none' || st.visibility === 'hidden' || st.pointerEvents === 'none') continue;
              const r = el.getBoundingClientRect();
              if (r.width < 4 || r.height < 4) continue;
              const ia = overlapArea(r, regionRect);
              const centerDist = Math.hypot((r.left + r.width/2) - cx, (r.top + r.height/2) - cy);
              const score = ia > 0 ? ia - centerDist : -centerDist;
              if (score > bestScore){ bestScore = score; best = el; }
            }
            target = best;
          }
          if (target){
            try { target.setAttribute('data-automation-click-target', token); } catch(e){}
            const p = toPoint(target);
            return { x: p.x, y: p.y, tag: p.tag, selector: `[data-automation-click-target="${token}"]` };
          }
          return null;
        }
        """
        try:
            result = self.page.evaluate(js, {"x": x, "y": y, "region": normalized_box, "token": token})
            if isinstance(result, dict) and 'x' in result and 'y' in result:
                rx, ry = int(result['x']), int(result['y'])
                rx = max(0, min(page_info.width - 1, rx))
                ry = max(0, min(page_info.height - 1, ry))
                try:
                    tag = result.get('tag')
                    if tag:
                        print(f"  Refinement found clickable <{tag}> at ({rx}, {ry})")
                except Exception:
                    pass
                selector = result.get('selector')
                return rx, ry, selector
        except Exception:
            pass
        return x, y, None

    def _execute_stop(self, step: ActionStep) -> bool:
        """Execute a stop action - returns True to indicate successful stop"""
        print("ðŸ›‘ STOP action executed - terminating automation")
        return True

    def _check_goal_achieved(self) -> bool:
        """Helper to check if any active goal has been achieved"""
        try:
            result = self.goal_monitor.evaluate_goal() if self.goal_monitor else None
            return result.status == GoalStatus.ACHIEVED if result else False
        except Exception:
            return False
    
    def _mark_element_as_interacted(self, step: ActionStep, elements: PageElements, interaction_type: str) -> None:
        """Mark an element as interacted with for deduplication"""
        if not self.deduper:
            print("âŒ No deduper to mark element as interacted with")
            return
        
        # Find the target element
        recorded_interaction = False

        if step.overlay_index is not None and elements and getattr(elements, 'elements', None):
            for element in elements.elements:
                if getattr(element, 'overlay_number', None) == step.overlay_index:
                    # Convert element to dict format expected by focus manager
                    description = getattr(element, 'description', None)
                    label = getattr(element, 'element_label', None)
                    element_dict = {
                        'tagName': getattr(element, 'element_type', '') or '',
                        'text': description or label or '',
                        'textContent': description or label or '',
                        'description': description or '',
                        'element_type': getattr(element, 'element_type', ''),
                        'href': getattr(element, 'href', ''),
                        'ariaLabel': getattr(element, 'aria_label', ''),
                        'aria_label': getattr(element, 'aria_label', ''),
                        'id': getattr(element, 'id', ''),
                        'role': getattr(element, 'role', '') or getattr(element, 'element_type', ''),
                        'overlayIndex': getattr(element, 'overlay_number', None) or step.overlay_index,
                        'box2d': getattr(element, 'box_2d', None),
                        'normalizedCoords': getattr(element, 'box_2d', None),
                    }
                    self.deduper.mark_element_as_interacted(element_dict, interaction_type)
                    recorded_interaction = True
                    break
                else:
                    print(f"âŒ No element found with overlay index {step.overlay_index} to mark as interacted with")

        if not recorded_interaction:
            action_value = ''
            if getattr(step, 'action', None):
                try:
                    action_value = step.action.value  # Enum value (e.g., 'click')
                except Exception:
                    action_value = str(step.action)
            text_value = step.text_to_type or action_value
            rect_data = None
            if step.x is not None and step.y is not None:
                rect_data = {
                    'x': step.x,
                    'y': step.y,
                    'width': 0,
                    'height': 0,
                }
            fallback_dict = {
                'tagName': '',
                'text': text_value,
                'textContent': text_value,
                'description': text_value,
                'element_type': action_value,
                'overlayIndex': step.overlay_index,
                'box2d': None,
                'normalizedCoords': None,
                'role': action_value,
                'rect': rect_data,
            }
            self.deduper.mark_element_as_interacted(fallback_dict, interaction_type)
            print(f"âŒ No element found with overlay index {step.overlay_index} to mark as interacted with")
