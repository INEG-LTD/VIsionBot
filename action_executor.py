"""
Executes actions generated by the vision planning system.
"""
import time
from typing import Tuple, Optional

from playwright.sync_api import Page
from models import ActionStep, ActionType, PageElements, PageInfo, DetectedElement
from handlers import DateTimeHandler, SelectHandler, UploadHandler
from utils import SelectorUtils
from vision_utils import validate_and_clamp_coordinates, get_gemini_box_2d_center_pixels
from goals import GoalMonitor, InteractionType, GoalStatus


class ActionExecutor:
    """Executes automation actions"""
    
    def __init__(self, page: Page, goal_monitor: GoalMonitor):
        self.page = page
        self.goal_monitor = goal_monitor
        
        # Initialize specialized handlers
        self.datetime_handler = DateTimeHandler(page, goal_monitor)
        self.select_handler = SelectHandler(page)
        self.upload_handler = UploadHandler(page)
        self.selector_utils = SelectorUtils(page)
    
    def execute_plan(self, plan, page_info: PageInfo) -> bool:
        """Execute the generated plan"""
        print(f"ðŸš€ Executing plan with {len(plan.action_steps)} steps")
        
        for i, step in enumerate(plan.action_steps):
            print(f"\n  Step {i+1}: {step.action}")
            
            try:
                step_success = True
                if step.action == ActionType.CLICK:
                    step_success = self._execute_click(step, plan.detected_elements, page_info)
                elif step.action == ActionType.TYPE:
                    step_success = self._execute_type(step, plan.detected_elements, page_info)
                elif step.action == ActionType.SCROLL:
                    step_success = self._execute_scroll(step)
                elif step.action == ActionType.WAIT:
                    step_success = self._execute_wait(step)
                elif step.action == ActionType.HANDLE_SELECT:
                    self.select_handler.handle_select_field(step, plan.detected_elements, page_info)
                    step_success = True  # Assume success for handlers that don't return values yet
                elif step.action == ActionType.HANDLE_UPLOAD:
                    self.upload_handler.handle_upload_field(step, plan.detected_elements, page_info)
                    step_success = True  # Assume success for handlers that don't return values yet
                elif step.action == ActionType.HANDLE_DATETIME:
                    self.datetime_handler.handle_datetime_field(step, plan.detected_elements, page_info)
                    step_success = True  # Assume success for handlers that don't return values yet
                else:
                    print(f"âš ï¸ Unknown action type: {step.action}")
                    continue
                
                # Check if step failed (e.g., due to retry request)
                if not step_success:
                    print(f"âŒ Step {i+1} failed - aborting plan execution")
                    return False
                
                # Small delay between actions
                time.sleep(0.5)
                
            except Exception as e:
                print(f"âŒ Error executing step {i+1}: {e}")
                return False
        
        print("âœ… Plan execution completed")
        return True

    def _execute_click(self, step: ActionStep, elements: PageElements, page_info: PageInfo) -> bool:
        """Execute a click action"""
        x, y = self._get_click_coordinates(step, elements, page_info)
        if x is None or y is None:
            raise ValueError("Could not determine click coordinates")
        
        # Validate and clamp coordinates to viewport
        x, y = validate_and_clamp_coordinates(x, y, page_info.width, page_info.height)
        
        # Record planned interaction with goal monitor and get pre-interaction evaluations
        pre_evaluations = self.goal_monitor.record_planned_interaction(
            InteractionType.CLICK,
            coordinates=(x, y)
        )
        
        # Check for retry requests from goals immediately after evaluation
        retry_goals = self.goal_monitor.check_for_retry_requests()
        if retry_goals:
            print("ðŸ”„ Goals have requested retry - aborting current plan execution")
            for goal in retry_goals:
                print(f"   ðŸ”„ {goal}: Retry requested (attempt {goal.retry_count}/{goal.max_retries})")
            # Return False to indicate plan should be regenerated
            return False
        
        # Check if any goals were achieved before the click
        if any(result.status == GoalStatus.ACHIEVED for result in pre_evaluations.values()):
            print("ðŸŽ¯ Goal achieved before click! Proceeding with click to complete the interaction.")
            for goal_name, result in pre_evaluations.items():
                if result.status == GoalStatus.ACHIEVED:
                    print(f"   âœ… {goal_name}: {result.reasoning}")
        elif any(result.status == GoalStatus.FAILED for result in pre_evaluations.values()):
            print("âš ï¸ Goal evaluation suggests this click may not achieve the target:")
            for goal_name, result in pre_evaluations.items():
                if result.status == GoalStatus.FAILED:
                    print(f"   âŒ {goal_name}: {result.reasoning}")
            # Continue with click anyway - the user's plan should be executed
        
        # print(f"Elements: {elements.model_dump_json()}")
        # print(f"Step: {step.model_dump_json()}")
        print(f"  Clicking at ({x}, {y})")
        
        try:
            self.page.mouse.click(x, y)
            success = True
            error_msg = None
        except Exception as e:
            success = False
            error_msg = str(e)
            print(f"  âŒ Click failed: {e}")
        
        # Record actual interaction with goal monitor
        self.goal_monitor.record_interaction(
            InteractionType.CLICK,
            coordinates=(x, y),
            success=success,
            error_message=error_msg
        )
        return success

    def _execute_type(self, step: ActionStep, elements: PageElements, page_info: PageInfo) -> bool:
        """Execute a type action"""
        if not step.text_to_type:
            print("âš ï¸ No text specified for TYPE action")
            return False
        
        # Click first to focus the element
        x, y = self._get_click_coordinates(step, elements, page_info)
        if x is not None and y is not None:
            # Validate and clamp coordinates to viewport
            x, y = validate_and_clamp_coordinates(x, y, page_info.width, page_info.height)
            self.page.mouse.click(x, y)
            time.sleep(0.2)
        
        print(f"  Typing: {step.text_to_type}")
        
        try:
            # Clear existing text first
            self.page.keyboard.type("")
            self.page.keyboard.type(step.text_to_type, delay=50)
            success = True
            error_msg = None
        except Exception as e:
            success = False
            error_msg = str(e)
            print(f"  âŒ Typing failed: {e}")
        
        # Record type interaction with goal monitor
        self.goal_monitor.record_interaction(
            InteractionType.TYPE,
            coordinates=(x, y) if x is not None and y is not None else None,
            text_input=step.text_to_type,
            success=success,
            error_message=error_msg
        )
        
        return success

    def _execute_scroll(self, step: ActionStep) -> bool:
        """Execute a scroll action"""
        direction = step.scroll_direction or "down"
        scroll_amount = 300
        
        if direction == "up":
            scroll_amount = -scroll_amount
        
        print(f"  Scrolling {direction}")
        self.page.evaluate(f"window.scrollBy(0, {scroll_amount})")
        return True

    def _execute_wait(self, step: ActionStep) -> bool:
        """Execute a wait action"""
        wait_time = step.wait_time_ms or 500
        print(f"  Waiting {wait_time}ms")
        time.sleep(wait_time / 1000)
        return True

    def _get_click_coordinates(self, step: ActionStep, elements: PageElements, page_info: PageInfo) -> Tuple[Optional[int], Optional[int]]:
        """Get the coordinates to click based on the step"""
        # If direct coordinates are provided, use them
        if step.x is not None and step.y is not None:
            return int(step.x), int(step.y)
        
        # If target element index is provided, use element center
        if step.target_element_index is not None:
            if 0 <= step.target_element_index < len(elements.elements):
                element = elements.elements[step.target_element_index]
                if element.box_2d:
                    # Convert Gemini box_2d to pixel coordinates
                    center_x, center_y = get_gemini_box_2d_center_pixels(
                        element.box_2d, page_info.width, page_info.height
                    )
                    if center_x > 0 or center_y > 0:  # Valid center found
                        return center_x, center_y
        
        return None, None
