"""
Executes actions generated by the vision planning system.
"""
import time
from typing import Tuple, Optional

from playwright.sync_api import Page
from models import ActionStep, ActionType, PageElements, PageInfo
from handlers import DateTimeHandler, SelectHandler, UploadHandler
from utils import SelectorUtils
from unittest.mock import Mock
from utils.page_utils import PageUtils
from vision_utils import validate_and_clamp_coordinates, get_gemini_box_2d_center_pixels
from goals import GoalMonitor, InteractionType, GoalStatus


class ActionExecutor:
    """Executes automation actions"""
    
    def __init__(self, page: Page, goal_monitor: GoalMonitor, page_utils:PageUtils=None):
        self.page = page
        self.goal_monitor = goal_monitor
        self.page_utils = page_utils
        
        # Initialize specialized handlers
        self.datetime_handler = DateTimeHandler(page, goal_monitor)
        self.select_handler = SelectHandler(page)
        self.upload_handler = UploadHandler(page)
        self.selector_utils = SelectorUtils(page)
    
    def execute_plan(self, plan, page_info: PageInfo) -> bool:
        """Execute the generated plan"""
        print(f"ðŸš€ Executing plan with {len(plan.action_steps)} steps")
        
        # Note: Only evaluate goals AFTER actions execute, not before

        for i, step in enumerate(plan.action_steps):
            print(f"\n  Step {i+1}: {step.action}")
            
            try:
                step_success = True
                if step.action == ActionType.CLICK:
                    step_success = self._execute_click(step, plan.detected_elements, page_info)
                elif step.action == ActionType.TYPE:
                    step_success = self._execute_type(step, plan.detected_elements, page_info)
                elif step.action == ActionType.SCROLL:
                    step_success = self._execute_scroll(step)
                elif step.action == ActionType.WAIT:
                    step_success = self._execute_wait(step)
                elif step.action == ActionType.PRESS:
                    step_success = self._execute_press(step)
                elif step.action == ActionType.HANDLE_SELECT:
                    self.select_handler.handle_select_field(step, plan.detected_elements, page_info)
                    step_success = True  # Assume success for handlers that don't return values yet
                elif step.action == ActionType.HANDLE_UPLOAD:
                    self.upload_handler.handle_upload_field(step, plan.detected_elements, page_info)
                    step_success = True  # Assume success for handlers that don't return values yet
                elif step.action == ActionType.HANDLE_DATETIME:
                    self.datetime_handler.handle_datetime_field(step, plan.detected_elements, page_info)
                    step_success = True  # Assume success for handlers that don't return values yet
                elif step.action == ActionType.STOP:
                    step_success = self._execute_stop(step)
                else:
                    print(f"âš ï¸ Unknown action type: {step.action}")
                    continue
                
                # Check if step failed (e.g., due to retry request)
                if not step_success:
                    print(f"âŒ Step {i+1} failed - aborting plan execution")
                    return False
                
                # Only check for goal achievement AFTER the action executes
                if self._check_goals_achieved():
                    print("âœ… Goal achieved during step execution. Ending plan early.")
                    return True

                # Small delay between actions
                time.sleep(0.5)
                
            except Exception as e:
                print(f"âŒ Error executing step {i+1}: {e}")
                return False
        
        print("âœ… Plan execution completed")
        return True

    def _execute_click(self, step: ActionStep, elements: PageElements, page_info: PageInfo) -> bool:
        """Execute a click action"""
        x, y = self._get_click_coordinates(step, elements, page_info)
        if x is None or y is None:
            raise ValueError("Could not determine click coordinates")

        # Try to resolve a truly clickable element (anchor/button/etc.) and remember a selector
        try:
            box = None
            if step.target_element_index is not None and elements and getattr(elements, 'elements', None):
                for el in elements.elements:
                    if getattr(el, 'overlay_number', None) == step.target_element_index and getattr(el, 'box_2d', None):
                        box = el.box_2d
                        break
            # Use robust resolver that marks the DOM node and returns a selector
            rx, ry, target_selector = self._resolve_click_target(x, y, page_info, normalized_box=box)
            if rx is not None and ry is not None and (rx != x or ry != y):
                print(f"  Adjusted click target to ({rx}, {ry}) from ({x}, {y}) for clickable element")
                x, y = rx, ry
        except Exception as _e:
            # Non-fatal; continue with original coordinates
            pass
        
        # Validate and clamp coordinates to viewport
        # x, y = validate_and_clamp_coordinates(x, y, page_info.width, page_info.height)
        
        # Record planned interaction with goal monitor and get pre-interaction evaluations
        pre_evaluations = self.goal_monitor.record_planned_interaction(
            InteractionType.CLICK,
            coordinates=(x, y),
            target_selector=locals().get('target_selector')
        )
        
        # Check for retry requests from goals immediately after evaluation
        retry_goals = self.goal_monitor.check_for_retry_requests()
        if retry_goals:
            print("ðŸ”„ Goals have requested retry - aborting current plan execution")
            for goal in retry_goals:
                print(f"   ðŸ”„ {goal}: Retry requested (attempt {goal.retry_count}/{goal.max_retries})")
            # Return False to indicate plan should be regenerated
            return False
        
        # Check if any goals were achieved before the click (informational only)
        if any(result.status == GoalStatus.ACHIEVED for result in pre_evaluations.values()):
            print("ðŸŽ¯ Goal achieved before click (pre-eval)! Proceeding with click as requested.")
            for goal_name, result in pre_evaluations.items():
                if result.status == GoalStatus.ACHIEVED:
                    print(f"   âœ… {goal_name}: {result.reasoning}")
        elif any(result.status == GoalStatus.FAILED for result in pre_evaluations.values()):
            print("âš ï¸ Goal evaluation suggests this click may not achieve the target:")
            for goal_name, result in pre_evaluations.items():
                if result.status == GoalStatus.FAILED:
                    print(f"   âŒ {goal_name}: {result.reasoning}")
            # Continue with click anyway - the user's plan should be executed
        
        # print(f"Elements: {elements.model_dump_json()}")
        # print(f"Step: {step.model_dump_json()}")
        print(f"  Clicking at ({x}, {y})")
        
        try:
            # If we resolved a specific target selector, try clicking that directly
            resolved_selector = locals().get('target_selector')
            if resolved_selector:
                try:
                    self.page.locator(resolved_selector).first.click(timeout=1500)
                    success = True
                    error_msg = None
                    # Cleanup temporary marker
                    try:
                        self.page.evaluate("() => document.querySelectorAll('[data-automation-click-target]')?.forEach(e => e.removeAttribute('data-automation-click-target'))")
                    except Exception:
                        pass
                    self.goal_monitor.record_interaction(
                        InteractionType.CLICK,
                        coordinates=(x, y),
                        success=success,
                        error_message=error_msg
                    )
                    return success
                except Exception:
                    pass

            # Overlay-based DOM click fallback
            if step.target_element_index is not None:
                selector = f'[data-automation-overlay-index="{step.target_element_index}"]'
                clickable_sel = selector + ' a, ' + selector + ' button, ' + selector + ' [role="link"], ' + selector + ' [role="button"], ' + selector + ' input, ' + selector + ' select, ' + selector + ' textarea'
                try:
                    count = self.page.locator(clickable_sel).count()
                except Exception:
                    count = 0
                if count > 0:
                    try:
                        self.page.locator(clickable_sel).first.click(timeout=1500)
                        success = True
                        error_msg = None
                        self.goal_monitor.record_interaction(
                            InteractionType.CLICK,
                            coordinates=(x, y),
                            success=success,
                            error_message=error_msg
                        )
                        return success
                    except Exception:
                        pass
            # Fallback to coordinate click
            self.page.mouse.click(x, y)
            success = True
            error_msg = None
        except Exception as e:
            success = False
            error_msg = str(e)
            print(f"  âŒ Click failed: {e}")
        
        # Record actual interaction with goal monitor
        self.goal_monitor.record_interaction(
            InteractionType.CLICK,
            coordinates=(x, y),
            success=success,
            error_message=error_msg
        )
        return success

    def _execute_type(self, step: ActionStep, elements: PageElements, page_info: PageInfo) -> bool:
        """Execute a type action"""
        if not step.text_to_type:
            print("âš ï¸ No text specified for TYPE action")
            return False
        
        # Click first to focus the element
        x, y = self._get_click_coordinates(step, elements, page_info)
        if x is not None and y is not None:
            # Validate and clamp coordinates to viewport
            # x, y = validate_and_clamp_coordinates(x, y, page_info.width, page_info.height)
            # Refine to a truly focusable/clickable target before clicking to focus
            try:
                box = None
                if step.target_element_index is not None and elements and getattr(elements, 'elements', None):
                    for el in elements.elements:
                        if getattr(el, 'overlay_number', None) == step.target_element_index and getattr(el, 'box_2d', None):
                            box = el.box_2d
                            break
                if step.target_element_index is not None:
                    ovx, ovy = self._find_clickable_point_from_overlay(step.target_element_index)
                    if ovx is not None and ovy is not None:
                        x, y = ovx, ovy
                rx, ry = self._refine_click_coordinates(x, y, page_info, normalized_box=box)
                if rx is not None and ry is not None:
                    x, y = rx, ry
            except Exception:
                pass
            self.page.mouse.click(x, y)
            time.sleep(0.2)
        
        print(f"  Typing: {step.text_to_type}")
        
        try:
            # Clear existing text first
            self.page.keyboard.type("")
            self.page.keyboard.type(step.text_to_type, delay=50)
            success = True
            error_msg = None
        except Exception as e:
            success = False
            error_msg = str(e)
            print(f"  âŒ Typing failed: {e}")
        
        # Record type interaction with goal monitor
        self.goal_monitor.record_interaction(
            InteractionType.TYPE,
            coordinates=(x, y) if x is not None and y is not None else None,
            text_input=step.text_to_type,
            success=success,
            error_message=error_msg
        )
        
        return success

    def _get_interpreted_scroll_position(self, direction: str):
        """Get the interpreted scroll target position from active ScrollGoal"""
        try:
            # Find active ScrollGoal
            from goals import ScrollGoal
            scroll_goals = [goal for goal in self.goal_monitor.active_goals if isinstance(goal, ScrollGoal)]
            
            if not scroll_goals:
                return None
            
            # Use the first ScrollGoal (there should typically be only one)
            scroll_goal = scroll_goals[0]
            
            # Create a basic context for interpretation
            from goals.base import GoalContext, BrowserState
            if self.page_utils:
                page_info = self.page_utils.get_page_info()
            else:
                # Fallback if page_utils is not available
                page_info = Mock()
                page_info.doc_height = 2000
                page_info.doc_width = 1200
                page_info.height = 800
                page_info.width = 1200
                page_info.scroll_x = 0
                page_info.scroll_y = 0
            
            # Get current scroll position
            current_scroll_x = self.page.evaluate("window.pageXOffset || window.scrollX") or 0
            current_scroll_y = self.page.evaluate("window.pageYOffset || window.scrollY") or 0
            
            # Create browser state
            browser_state = BrowserState(
                timestamp=0,
                url=page_info.url,
                title=page_info.title,
                page_height=page_info.doc_height,
                page_width=page_info.doc_width,
                scroll_x=current_scroll_x,
                scroll_y=current_scroll_y
            )
            
            print(f"Page height: {page_info.doc_height}, Page width: {page_info.doc_width}")
            
            # Create goal context
            context = GoalContext(
                initial_state=browser_state,
                current_state=browser_state,
            )
            
            # Get interpreted scroll from ScrollGoal
            interpretation = scroll_goal.interpret_request(context)
            if interpretation:
                print(f"[ActionExecutor] ScrollGoal interpreted '{scroll_goal.user_request}' as target position ({interpretation.target_x}, {interpretation.target_y}) {interpretation.direction} ({interpretation.axis})")
                return interpretation
            
            return None
            
        except Exception as e:
            print(f"[ActionExecutor] Error getting interpreted scroll position: {e}")
            return None

    def _execute_scroll(self, step: ActionStep) -> bool:
        """Execute a scroll action"""
        direction = step.scroll_direction or "down"
        axis = "vertical"  # Default to vertical
        
        # Get current scroll position
        current_scroll_x = self.page.evaluate("window.pageXOffset || window.scrollX") or 0
        current_scroll_y = self.page.evaluate("window.pageYOffset || window.scrollY") or 0
        
        # Try to get the interpreted scroll position from ScrollGoal
        interpreted_scroll = self._get_interpreted_scroll_position(direction)
        if interpreted_scroll:
            target_x = interpreted_scroll.target_x
            target_y = interpreted_scroll.target_y
            axis = interpreted_scroll.axis
            direction = interpreted_scroll.direction
            print(f"[ActionExecutor] Using interpreted scroll: target position ({target_x}, {target_y}) {direction} ({axis})")
        else:
            # Fallback to default scroll behavior
            if direction == "down":
                target_x = current_scroll_x
                target_y = min(current_scroll_y + 300, 9999)  # Default 300px down
            elif direction == "up":
                target_x = current_scroll_x
                target_y = max(current_scroll_y - 300, 0)  # Default 300px up
            elif direction == "right":
                target_x = min(current_scroll_x + 300, 9999)  # Default 300px right
                target_y = current_scroll_y
                axis = "horizontal"
            else:  # left
                target_x = max(current_scroll_x - 300, 0)  # Default 300px left
                target_y = current_scroll_y
                axis = "horizontal"
            print(f"[ActionExecutor] Using default scroll: target position ({target_x}, {target_y}) {direction} ({axis})")
        
        # Record planned interaction with goal monitor and get pre-interaction evaluations
        pre_evaluations = self.goal_monitor.record_planned_interaction(
            InteractionType.SCROLL,
            target_x=target_x,
            target_y=target_y,
            scroll_direction=direction,
            scroll_axis=axis
        )
        
        # Check for retry requests from goals immediately after evaluation
        retry_goals = self.goal_monitor.check_for_retry_requests()
        if retry_goals:
            print("ðŸ”„ Goals have requested retry - aborting current plan execution")
            for goal in retry_goals:
                print(f"   ðŸ”„ {goal}: Retry requested (attempt {goal.retry_count}/{goal.max_retries})")
            # Return False to indicate plan should be regenerated
            return False
        
        # Check if any goals were achieved before the scroll (informational only)
        if any(result.status == GoalStatus.ACHIEVED for result in pre_evaluations.values()):
            print("ðŸŽ¯ Goal achieved before scroll (pre-eval)! Proceeding with scroll as requested.")
            for goal_name, result in pre_evaluations.items():
                if result.status == GoalStatus.ACHIEVED:
                    print(f"   âœ… {goal_name}: {result.reasoning}")
        elif any(result.status == GoalStatus.FAILED for result in pre_evaluations.values()):
            print("âš ï¸ Goal evaluation suggests this scroll may not achieve the target:")
            for goal_name, result in pre_evaluations.items():
                if result.status == GoalStatus.FAILED:
                    print(f"   âŒ {goal_name}: {result.reasoning}")
            # Continue with scroll anyway - the user's plan should be executed
        
        print(f"  Scrolling to position ({target_x}, {target_y}) {direction} ({axis})")
        
        try:
            self.page.evaluate(f"window.scrollTo({target_x}, {target_y})")
            success = True
            error_msg = None
        except Exception as e:
            success = False
            error_msg = str(e)
            print(f"  âŒ Scroll failed: {e}")
        
        # Record actual interaction with goal monitor
        self.goal_monitor.record_interaction(
            InteractionType.SCROLL,
            target_x=target_x,
            target_y=target_y,
            scroll_direction=direction,
            scroll_axis=axis,
            success=success,
            error_message=error_msg
        )
        
        return success

    def _execute_wait(self, step: ActionStep) -> bool:
        """Execute a wait action"""
        wait_time = step.wait_time_ms or 500
        print(f"  Waiting {wait_time}ms")
        time.sleep(wait_time / 1000)
        return True

    def _execute_press(self, step: ActionStep) -> bool:
        """Execute a key press action"""
        if not step.keys_to_press:
            print("âš ï¸ No keys specified for PRESS action")
            return False
        
        print(f"  Pressing keys: {step.keys_to_press}")
        
        # Record planned interaction with goal monitor
        pre_evaluations = self.goal_monitor.record_planned_interaction(
            InteractionType.PRESS,
            keys_to_press=step.keys_to_press
        )
        
        # Check for retry requests from goals immediately after evaluation
        retry_goals = self.goal_monitor.check_for_retry_requests()
        if retry_goals:
            print("ðŸ”„ Goals have requested retry - aborting current plan execution")
            for goal in retry_goals:
                print(f"   ðŸ”„ {goal}: Retry requested (attempt {goal.retry_count}/{goal.max_retries})")
            return False
        
        # Check if any goals were achieved before the press (informational only)
        if any(result.status == GoalStatus.ACHIEVED for result in pre_evaluations.values()):
            print("ðŸŽ¯ Goal achieved before key press (pre-eval)! Proceeding with press as requested.")
            for goal_name, result in pre_evaluations.items():
                if result.status == GoalStatus.ACHIEVED:
                    print(f"   âœ… {goal_name}: {result.reasoning}")
        elif any(result.status == GoalStatus.FAILED for result in pre_evaluations.values()):
            print("âš ï¸ Goal evaluation suggests this key press may not achieve the target:")
            for goal_name, result in pre_evaluations.items():
                if result.status == GoalStatus.FAILED:
                    print(f"   âŒ {goal_name}: {result.reasoning}")
        
        try:
            # Parse and execute the key combination
            self._parse_and_press_keys(step.keys_to_press)
            success = True
            error_msg = None
        except Exception as e:
            success = False
            error_msg = str(e)
            print(f"  âŒ Key press failed: {e}")
        
        # Record actual interaction with goal monitor
        self.goal_monitor.record_interaction(
            InteractionType.PRESS,
            keys_pressed=step.keys_to_press,
            success=success,
            error_message=error_msg
        )
        
        return success
    
    def _parse_and_press_keys(self, keys_string: str) -> None:
        """Parse a key string and execute the key press(es)"""
        # Normalize the key string
        keys_string = keys_string.lower().strip()
        
        # Handle common key combinations
        if '+' in keys_string:
            # Handle key combinations like "ctrl+c", "cmd+enter", etc.
            parts = keys_string.split('+')
            modifiers = parts[:-1]
            main_key = parts[-1]
            
            # Map common modifier names
            modifier_map = {
                'ctrl': 'Control',
                'control': 'Control',
                'cmd': 'Meta',
                'command': 'Meta',
                'meta': 'Meta',
                'alt': 'Alt',
                'option': 'Alt',
                'shift': 'Shift'
            }
            
            # Map common key names
            key_map = {
                'enter': 'Enter',
                'return': 'Enter',
                'tab': 'Tab',
                'space': ' ',
                'esc': 'Escape',
                'escape': 'Escape',
                'backspace': 'Backspace',
                'delete': 'Delete',
                'del': 'Delete',
                'up': 'ArrowUp',
                'down': 'ArrowDown',
                'left': 'ArrowLeft',
                'right': 'ArrowRight',
                'home': 'Home',
                'end': 'End',
                'pageup': 'PageUp',
                'pagedown': 'PageDown',
                'f1': 'F1',
                'f2': 'F2',
                'f3': 'F3',
                'f4': 'F4',
                'f5': 'F5',
                'f6': 'F6',
                'f7': 'F7',
                'f8': 'F8',
                'f9': 'F9',
                'f10': 'F10',
                'f11': 'F11',
                'f12': 'F12'
            }
            
            # Convert modifiers
            playwright_modifiers = []
            for mod in modifiers:
                playwright_mod = modifier_map.get(mod.strip())
                if playwright_mod:
                    playwright_modifiers.append(playwright_mod)
            
            # Convert main key
            playwright_key = key_map.get(main_key.strip(), main_key.strip())
            
            # Execute the key combination
            if playwright_modifiers:
                self.page.keyboard.press(f"{'+'.join(playwright_modifiers)}+{playwright_key}")
            else:
                self.page.keyboard.press(playwright_key)
        else:
            # Handle single keys
            key_map = {
                'enter': 'Enter',
                'return': 'Enter',
                'tab': 'Tab',
                'space': ' ',
                'esc': 'Escape',
                'escape': 'Escape',
                'backspace': 'Backspace',
                'delete': 'Delete',
                'del': 'Delete',
                'up': 'ArrowUp',
                'down': 'ArrowDown',
                'left': 'ArrowLeft',
                'right': 'ArrowRight',
                'home': 'Home',
                'end': 'End',
                'pageup': 'PageUp',
                'pagedown': 'PageDown',
                'f1': 'F1',
                'f2': 'F2',
                'f3': 'F3',
                'f4': 'F4',
                'f5': 'F5',
                'f6': 'F6',
                'f7': 'F7',
                'f8': 'F8',
                'f9': 'F9',
                'f10': 'F10',
                'f11': 'F11',
                'f12': 'F12'
            }
            
            playwright_key = key_map.get(keys_string, keys_string)
            self.page.keyboard.press(playwright_key)

    def _get_click_coordinates(self, step: ActionStep, elements: PageElements, page_info: PageInfo) -> Tuple[Optional[int], Optional[int]]:
        """Get the coordinates to click based on the step"""
        # Prefer overlay index â†’ convert to pixel center from normalized box
        if step.target_element_index is not None:
            # First try to find by overlay number (preferred)
            for element in elements.elements:
                if element.overlay_number == step.target_element_index and element.box_2d:
                    center_x, center_y = get_gemini_box_2d_center_pixels(
                        element.box_2d, page_info.width, page_info.height
                    )
                    if center_x > 0 or center_y > 0:
                        return center_x, center_y
            # Fallback to array index (legacy support)
            if 0 <= step.target_element_index < len(elements.elements):
                element = elements.elements[step.target_element_index]
                if element.box_2d:
                    center_x, center_y = get_gemini_box_2d_center_pixels(
                        element.box_2d, page_info.width, page_info.height
                    )
                    if center_x > 0 or center_y > 0:
                        return center_x, center_y

        # Fallback: use raw coordinates if provided
        if step.x is not None and step.y is not None:
            return int(step.x), int(step.y)
        
        return None, None

    def _find_clickable_point_from_overlay(self, overlay_index: int) -> Tuple[Optional[int], Optional[int]]:
        """Given an overlay index, try to find a clickable descendant within that element and return its center.

        Uses the 'data-automation-overlay-index' attribute set during overlay creation to locate the element.
        """
        js = r"""
        (idx) => {
          const sel = `[data-automation-overlay-index="${idx}"]`;
          const root = document.querySelector(sel);
          if (!root) return null;
          const cand = root.querySelector('a,button,[role="link"],[role="button"],input,select,textarea') || root;
          const r = cand.getBoundingClientRect();
          const cx = Math.round(r.left + r.width/2);
          const cy = Math.round(r.top + r.height/2);
          return {x: cx, y: cy};
        }
        """
        try:
            res = self.page.evaluate(js, overlay_index)
            if isinstance(res, dict) and 'x' in res and 'y' in res:
                return int(res['x']), int(res['y'])
        except Exception:
            pass
        return None, None

    def _refine_click_coordinates(self, x: int, y: int, page_info: PageInfo, normalized_box=None) -> Tuple[Optional[int], Optional[int]]:
        """Refine coordinates to the center of the nearest clickable element at/within the region.

        - First try the exact point (x,y): ascend to a clickable ancestor.
        - If not found, sample multiple points within the element box (if provided) or around (x,y).
        - Clickable definition: anchor/button/input/select/textarea or role=button/link, onclick, tabindex, pointer cursor.
        """
        js = r"""
        (arg) => {
          const x = arg && arg.x !== undefined ? arg.x : 0;
          const y = arg && arg.y !== undefined ? arg.y : 0;
          const region = arg ? arg.region : null;
          function isClickable(el) {
            if (!el || el.nodeType !== 1) return false;
            const tag = el.tagName.toLowerCase();
            if (["a","button","input","select","textarea","summary","label"].includes(tag)) return true;
            const role = el.getAttribute && el.getAttribute('role');
            if (role && ["button","link","tab","menuitem","option","combobox"].includes(role.toLowerCase())) return true;
            if (el.onclick || el.getAttribute && el.getAttribute('onclick')) return true;
            if (el.hasAttribute && el.hasAttribute('tabindex') && el.getAttribute('tabindex') !== '-1') return true;
            const style = window.getComputedStyle(el);
            if (style && style.cursor === 'pointer') return true;
            return false;
          }

          function toPoint(el){
            const r = el.getBoundingClientRect();
            return {x: Math.round(r.left + r.width/2), y: Math.round(r.top + r.height/2), tag: el.tagName.toLowerCase()};
          }

          function findClickableFromPoint(px, py){
            let el = document.elementFromPoint(px, py);
            // Ascend to clickable ancestor
            let cur = el;
            while (cur && cur !== document.body && !isClickable(cur)) cur = cur.parentElement;
            if (cur && isClickable(cur)) return toPoint(cur);
            // Try clickable descendant from the element
            if (el && el.querySelector) {
              const cand = el.querySelector('a,button,input,select,textarea,[role="button"],[role="link"],[onclick],[tabindex]');
              if (cand) return toPoint(cand);
            }
            // Try closest anchor for common SERP structures (h3 within a)
            if (el && el.closest) {
              const link = el.closest('a,[role="link"]');
              if (link) return toPoint(link);
            }
            return null;
          }

          function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }

          // Region rectangle in viewport pixels
          const vw = window.innerWidth, vh = window.innerHeight;
          let xMin, yMin, xMax, yMax;
          if (region && Array.isArray(region) && region.length === 4){
            yMin = region[0]/1000*vh; xMin = region[1]/1000*vw; yMax = region[2]/1000*vh; xMax = region[3]/1000*vw;
          } else {
            const w = 220, h = 140; // default search window around the point
            xMin = x - w/2; xMax = x + w/2; yMin = y - h/2; yMax = y + h/2;
          }
          xMin = clamp(Math.round(xMin), 0, vw-1); xMax = clamp(Math.round(xMax), 0, vw-1);
          yMin = clamp(Math.round(yMin), 0, vh-1); yMax = clamp(Math.round(yMax), 0, vh-1);
          const cx = Math.round((xMin + xMax)/2), cy = Math.round((yMin + yMax)/2);

          // Build sample points (center, edges, corners)
          const pts = [
            [cx, cy],
            [xMin + 4, cy], [xMax - 4, cy],
            [cx, yMin + 4], [cx, yMax - 4],
            [xMin + 8, yMin + 8], [xMax - 8, yMin + 8],
            [xMin + 8, yMax - 8], [xMax - 8, yMax - 8]
          ];
          for (const [sx, sy] of pts){
            const p = findClickableFromPoint(sx, sy);
            if (p) return p;
          }

          // Fallback: search clickable elements intersecting the region
          function overlapArea(r1, r2){
            const x1 = Math.max(r1.left, r2.left), y1 = Math.max(r1.top, r2.top);
            const x2 = Math.min(r1.right, r2.right), y2 = Math.min(r1.bottom, r2.bottom);
            const w = Math.max(0, x2 - x1), h = Math.max(0, y2 - y1);
            return w * h;
          }
          const regionRect = {left: xMin, top: yMin, right: xMax, bottom: yMax};
          const candSel = 'a,button,[role="link"],[role="button"],input,select,textarea';
          const cands = Array.from(document.querySelectorAll(candSel))
            .filter(el => {
              const st = getComputedStyle(el);
              if (st.display === 'none' || st.visibility === 'hidden' || st.pointerEvents === 'none') return false;
              const r = el.getBoundingClientRect();
              if (r.width < 4 || r.height < 4) return false;
              return true;
            });
          let best = null, bestScore = -1;
          for (const el of cands){
            const r = el.getBoundingClientRect();
            const ia = overlapArea(r, regionRect);
            const centerDist = Math.hypot((r.left + r.width/2) - cx, (r.top + r.height/2) - cy);
            // Score: prioritize overlap, break ties by closeness to center
            const score = ia > 0 ? ia - centerDist : -centerDist;
            if (score > bestScore){ bestScore = score; best = el; }
          }
          if (best) return toPoint(best);

          return null;
        }
        """

        try:
            result = self.page.evaluate(js, {"x": x, "y": y, "region": normalized_box})
            if result and isinstance(result, dict) and 'x' in result and 'y' in result:
                rx, ry = int(result['x']), int(result['y'])
                # Clamp to viewport
                rx = max(0, min(page_info.width - 1, rx))
                ry = max(0, min(page_info.height - 1, ry))
                try:
                    tag = result.get('tag')
                    if tag:
                        print(f"  Refinement found clickable <{tag}> at ({rx}, {ry})")
                except Exception:
                    pass
                return rx, ry
        except Exception:
            pass
        return x, y

    def _resolve_click_target(self, x: int, y: int, page_info: PageInfo, normalized_box=None) -> Tuple[Optional[int], Optional[int], Optional[str]]:
        """Resolve a clickable element near a point/region and mark it with a temporary selector.

        Returns (rx, ry, selector) where selector is a CSS selector to the marked element.
        """
        import random
        token = f"auto-{int(time.time()*1000)}-{random.randint(1000,9999)}"
        js = r"""
        ({ x, y, region, token }) => {
          function isClickable(el) {
            if (!el || el.nodeType !== 1) return false;
            const tag = el.tagName.toLowerCase();
            if (["a","button","input","select","textarea","summary","label"].includes(tag)) return true;
            const role = el.getAttribute && el.getAttribute('role');
            if (role && ["button","link","tab","menuitem","option","combobox"].includes(role.toLowerCase())) return true;
            if (el.onclick || el.getAttribute && el.getAttribute('onclick')) return true;
            if (el.hasAttribute && el.hasAttribute('tabindex') && el.getAttribute('tabindex') !== '-1') return true;
            const style = window.getComputedStyle(el);
            if (style && style.cursor === 'pointer') return true;
            return false;
          }
          function toPoint(el){
            const r = el.getBoundingClientRect();
            return {x: Math.round(r.left + r.width/2), y: Math.round(r.top + r.height/2), tag: el.tagName.toLowerCase()};
          }
          function findClickableFromPoint(px, py){
            let el = document.elementFromPoint(px, py);
            let cur = el;
            while (cur && cur !== document.body && !isClickable(cur)) cur = cur.parentElement;
            if (cur && isClickable(cur)) return cur;
            if (el && el.querySelector) {
              const cand = el.querySelector('a,button,input,select,textarea,[role="button"],[role="link"],[onclick],[tabindex]');
              if (cand) return cand;
            }
            if (el && el.closest) {
              const link = el.closest('a,[role="link"]');
              if (link) return link;
            }
            return null;
          }
          function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }
          const vw = window.innerWidth, vh = window.innerHeight;
          let xMin, yMin, xMax, yMax;
          if (region && Array.isArray(region) && region.length === 4){
            yMin = region[0]/1000*vh; xMin = region[1]/1000*vw; yMax = region[2]/1000*vh; xMax = region[3]/1000*vw;
          } else {
            const w = 220, h = 140;
            xMin = x - w/2; xMax = x + w/2; yMin = y - h/2; yMax = y + h/2;
          }
          xMin = clamp(Math.round(xMin), 0, vw-1); xMax = clamp(Math.round(xMax), 0, vw-1);
          yMin = clamp(Math.round(yMin), 0, vh-1); yMax = clamp(Math.round(yMax), 0, vh-1);
          const cx = Math.round((xMin + xMax)/2), cy = Math.round((yMin + yMax)/2);
          const pts = [ [cx, cy], [xMin+4, cy], [xMax-4, cy], [cx, yMin+4], [cx, yMax-4], [xMin+8, yMin+8], [xMax-8, yMin+8], [xMin+8, yMax-8], [xMax-8, yMax-8] ];
          let target = null;
          for (const [sx, sy] of pts){
            const cand = findClickableFromPoint(sx, sy);
            if (cand){ target = cand; break; }
          }
          if (!target){
            // Fallback: search clickable elements overlapping the region
            const regionRect = {left: xMin, top: yMin, right: xMax, bottom: yMax};
            function overlapArea(r1, r2){
              const x1 = Math.max(r1.left, r2.left), y1 = Math.max(r1.top, r2.top);
              const x2 = Math.min(r1.right, r2.right), y2 = Math.min(r1.bottom, r2.bottom);
              const w = Math.max(0, x2 - x1), h = Math.max(0, y2 - y1);
              return w * h;
            }
            const candSel = 'a,button,[role="link"],[role="button"],input,select,textarea';
            let best = null, bestScore = -1;
            for (const el of document.querySelectorAll(candSel)){
              const st = getComputedStyle(el);
              if (st.display === 'none' || st.visibility === 'hidden' || st.pointerEvents === 'none') continue;
              const r = el.getBoundingClientRect();
              if (r.width < 4 || r.height < 4) continue;
              const ia = overlapArea(r, regionRect);
              const centerDist = Math.hypot((r.left + r.width/2) - cx, (r.top + r.height/2) - cy);
              const score = ia > 0 ? ia - centerDist : -centerDist;
              if (score > bestScore){ bestScore = score; best = el; }
            }
            target = best;
          }
          if (target){
            try { target.setAttribute('data-automation-click-target', token); } catch(e){}
            const p = toPoint(target);
            return { x: p.x, y: p.y, tag: p.tag, selector: `[data-automation-click-target="${token}"]` };
          }
          return null;
        }
        """
        try:
            result = self.page.evaluate(js, {"x": x, "y": y, "region": normalized_box, "token": token})
            if isinstance(result, dict) and 'x' in result and 'y' in result:
                rx, ry = int(result['x']), int(result['y'])
                rx = max(0, min(page_info.width - 1, rx))
                ry = max(0, min(page_info.height - 1, ry))
                try:
                    tag = result.get('tag')
                    if tag:
                        print(f"  Refinement found clickable <{tag}> at ({rx}, {ry})")
                except Exception:
                    pass
                selector = result.get('selector')
                return rx, ry, selector
        except Exception:
            pass
        return x, y, None

    def _execute_stop(self, step: ActionStep) -> bool:
        """Execute a stop action - returns True to indicate successful stop"""
        print("ðŸ›‘ STOP action executed - terminating automation")
        return True

    def _check_goals_achieved(self) -> bool:
        """Helper to check if any active goal has been achieved"""
        try:
            results = self.goal_monitor.evaluate_goals() if self.goal_monitor else {}
            return any(r.status == GoalStatus.ACHIEVED for r in results.values())
        except Exception:
            return False
