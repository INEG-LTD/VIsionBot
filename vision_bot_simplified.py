"""
Vision Bot - Clean coordinate-based Playwright automation using vision models.
"""
from __future__ import annotations

import hashlib
import re
import time
from enum import Enum
from typing import List, Optional, Tuple

from pydantic import BaseModel, Field, field_validator
from playwright.sync_api import Page

from ai_utils import generate_model
from vision_utils import (
    clamp_coordinate,
    validate_and_clamp_coordinates,
    validate_gemini_box_2d,
    get_gemini_box_2d_center_pixels,
    draw_bounding_boxes
)
from goals import (
    GoalMonitor,
    ClickGoal,
    NavigationGoal,
    InteractionType,
    GoalStatus
)


# =============================================================================
# Core Data Models - Simplified
# =============================================================================

class ActionType(str, Enum):
    CLICK = "click"
    TYPE = "type"
    SCROLL = "scroll"
    WAIT = "wait"


class PageSection(str, Enum):
    HEADER = "header"
    CONTENT = "content"
    SIDEBAR = "sidebar"
    MODAL = "modal"
    FOOTER = "footer"

class PageElements(BaseModel):
    """A list of detected elements on the page"""
    elements: List[DetectedElement] = Field(description="The list of detected elements")

class DetectedElement(BaseModel):
    """A UI element detected in the screenshot"""
    description: str = Field(description="What this element is (e.g., 'Submit button', 'Email input')")
    element_type: str = Field(description="Type: button, input, link, text, etc.")
    is_clickable: bool = Field(description="Can this element be clicked?")
    box_2d: List[int] = Field(description="Gemini format: [y_min, x_min, y_max, x_max] normalized 0-1000")
    section: PageSection = Field(description="Which section of the page this is in")
    confidence: float = Field(description="Detection confidence 0.0-1.0", ge=0.0, le=1.0)

    @field_validator("box_2d")
    @classmethod
    def validate_box_2d_field(cls, box):
        return validate_gemini_box_2d(box)


class ActionStep(BaseModel):
    """A single action to perform"""
    action: ActionType
    target_element_index: Optional[int] = Field(default=None, description="Index of target element from detections")
    x: Optional[int] = Field(default=None, description="X coordinate in pixels")
    y: Optional[int] = Field(default=None, description="Y coordinate in pixels")
    text_to_type: Optional[str] = Field(default=None, description="Text to type (for TYPE action)")
    wait_time_ms: Optional[int] = Field(default=500, description="Time to wait in milliseconds (for WAIT action)")
    scroll_direction: Optional[str] = Field(default="down", description="Scroll direction: up/down")


class VisionPlan(BaseModel):
    """Plan generated by the vision model"""
    detected_elements: PageElements = Field(description="All detected UI elements")
    action_steps: List[ActionStep] = Field(description="Steps to execute")
    reasoning: str = Field(description="Why this plan was chosen")
    confidence: float = Field(description="Overall confidence in this plan", ge=0.0, le=1.0)


class Goal(BaseModel):
    """Goal definition"""
    description: str = Field(description="What we want to achieve")
    target_url_contains: List[str] = Field(default_factory=list, description="URL should contain these strings")
    target_page_text: List[str] = Field(default_factory=list, description="Page should contain this text")
    form_should_be_filled: bool = Field(default=False, description="All required form fields should be filled")


# =============================================================================
# Page Information
# =============================================================================

class PageInfo(BaseModel):
    """Information about the current page state"""
    width: int = Field(description="Current page width in pixels")
    height: int = Field(description="Current page height in pixels")
    scroll_x: int = Field(description="Current scroll X position")
    scroll_y: int = Field(description="Current scroll Y position")
    url: str = Field(description="Current page URL")
    title: str = Field(description="Current page title")
    dpr: float = Field(description="Device pixel ratio")
    ss_pixel_w: int = Field(description="Screenshot pixel width")
    ss_pixel_h: int = Field(description="Screenshot pixel height")
    css_scale: float = Field(description="CSS scale")
    doc_width: int = Field(description="Document width in pixels")
    doc_height: int = Field(description="Document height in pixels")

# =============================================================================
# Main Vision Bot Class - Simplified
# =============================================================================

class VisionBot:
    """
    Simplified vision-based web automation bot.
    
    Takes screenshots, uses vision models to understand the page,
    and executes actions to achieve goals.
    """

    def __init__(
        self,
        page: Page,
        model_name: str = "gemini-2.5-flash-lite",
        max_attempts: int = 10,
    ):
        self.page = page
        self.model_name = model_name
        self.max_attempts = max_attempts
        
        # State tracking
        self.current_attempt = 0
        self.last_screenshot_hash = None
        self.executed_actions = []
        
        # Goal framework integration
        self.goal_monitor = GoalMonitor(page)
        self.active_goals = []

    # =========================================================================
    # Core Methods
    # =========================================================================

    def achieve_goal(self, goal_description: str, additional_context: str = "", smart_goals: bool = True) -> bool:
        """
        Main method to achieve a goal using vision-based automation.
        
        Args:
            goal_description: What you want to achieve (e.g., "Fill out the contact form")
            additional_context: Extra context to help the vision model
            smart_goals: Whether to use the smart goal framework for monitoring
            
        Returns:
            True if goal achieved, False otherwise
        """
        print(f"ðŸŽ¯ Starting goal: {goal_description}")
        
        # Set up smart goal monitoring if enabled
        if smart_goals:
            self._setup_smart_goals(goal_description, additional_context)
        
        print(f"ðŸ” Smart goals setup: {self.goal_monitor.active_goals}\n")
        
        # Traditional goal object (not used with smart goals)
        # goal = Goal(description=goal_description)
        
        for attempt in range(self.max_attempts):
            self.current_attempt = attempt + 1
            print(f"\n--- Attempt {self.current_attempt}/{self.max_attempts} ---")
            
            # Check if goal is already achieved (smart goals or traditional)
            if smart_goals:
                goal_results = self.goal_monitor.evaluate_goals()
                if any(result.status == GoalStatus.ACHIEVED for result in goal_results.values()):
                    print("âœ… Smart goal achieved!")
                    self._print_goal_summary()
                    return True
            # Traditional goal checking disabled for now
            # elif self._is_goal_achieved(goal):
            #     print("âœ… Goal achieved!")
            #     return True
            
            # Get current page state
            page_info = self._get_page_info()
            screenshot = self._take_screenshot()
            
            # Skip if we've seen this exact screenshot recently (avoid loops)
            screenshot_hash = hashlib.md5(screenshot).hexdigest()
            if screenshot_hash == self.last_screenshot_hash:
                print("âš ï¸ Same screenshot as last attempt, scrolling to break loop")
                self._scroll_page()
                continue
            self.last_screenshot_hash = screenshot_hash
            
            # Generate plan using vision model
            plan = self._generate_plan(goal_description, additional_context, screenshot, page_info)
            if not plan or not plan.action_steps:
                print("âŒ No valid plan generated")
                continue
            
            print(f"ðŸ“‹ Generated plan with {len(plan.action_steps)} steps")
            print(f"ðŸ¤” Reasoning: {plan.reasoning}")
            
            # Execute the plan
            success = self._execute_plan(plan, page_info)
            if success:
                if smart_goals:
                    # Check if goals were achieved during execution (pre-interaction evaluations)
                    goal_results = self.goal_monitor.evaluate_goals()
                    if any(result.status == GoalStatus.ACHIEVED for result in goal_results.values()):
                        print("âœ… Smart goal achieved during plan execution!")
                        self._print_goal_summary()
                        return True
                    
                    # Wait a bit for page to update, then check goal again (post-interaction)
                    time.sleep(1)
                    goal_results = self.goal_monitor.evaluate_goals()
                    if any(result.status == GoalStatus.ACHIEVED for result in goal_results.values()):
                        print("âœ… Smart goal achieved after executing plan!")
                        self._print_goal_summary()
                        return True
                # Traditional goal checking disabled for now
                # elif self._is_goal_achieved(goal):
                #     print("âœ… Goal achieved after executing plan!")
                #     return True
        
        print(f"âŒ Failed to achieve goal after {self.max_attempts} attempts")
        if smart_goals:
            self._print_goal_summary()
        return False

    def _setup_smart_goals(self, goal_description: str, additional_context: str = "") -> None:
        """
        Set up smart goals based on the goal description.
        This analyzes the goal and creates appropriate monitoring goals.
        """
        goal_lower = goal_description.lower().strip()
        
        # Detect click goals
        click_patterns = [
            "click", "tap", "press", "select", "choose", "close", "dismiss",
            "click on", "click the", "press the", "tap the", "close the", "dismiss the"
        ]
        
        if any(pattern in goal_lower for pattern in click_patterns):
            # Extract what should be clicked
            target_description = self._extract_click_target(goal_description)
            if target_description:
                click_goal = ClickGoal(
                    description=f"Click goal: {goal_description}",
                    target_description=target_description
                )
                self.goal_monitor.add_goal(click_goal)
                print(f"ðŸŽ¯ Added ClickGoal: '{target_description}'")
        
        # Detect navigation goals
        navigation_patterns = [
            "go to", "navigate to", "open", "visit", "take me to",
            "go", "navigate", "open the", "visit the"
        ]
        
        if any(pattern in goal_lower for pattern in navigation_patterns):
            # Extract navigation intent
            navigation_intent = self._extract_navigation_intent(goal_description)
            if navigation_intent:
                nav_goal = NavigationGoal(
                    description=f"Navigation goal: {goal_description}",
                    navigation_intent=navigation_intent
                )
                self.goal_monitor.add_goal(nav_goal)
                print(f"ðŸ§­ Added NavigationGoal: '{navigation_intent}'")
        
        # Future: Add more goal types here
        # - FormFillGoal for "fill", "enter", "type"
        # - TextVerificationGoal for "verify", "check", "confirm"
    
    def _extract_click_target(self, goal_description: str) -> Optional[str]:
        """
        Extract what should be clicked from a goal description.
        Examples:
        - "click the submit button" -> "submit button"
        - "click on the first link" -> "first link"
        - "press the login button" -> "login button"
        """
        
        # Patterns to extract click targets
        patterns = [
            r"click (?:on )?(?:the )?(.+)",
            r"tap (?:on )?(?:the )?(.+)",
            r"press (?:the )?(.+)",
            r"select (?:the )?(.+)",
            r"choose (?:the )?(.+)",
            r"close (?:the )?(.+)",
            r"dismiss (?:the )?(.+)"
        ]
        
        goal_lower = goal_description.lower().strip()
        
        for pattern in patterns:
            match = re.search(pattern, goal_lower)
            if match:
                target = match.group(1).strip()
                # Clean up common endings
                target = re.sub(r'\s+(button|link|element|item)$', r' \1', target)
                return target
        
        return None
    
    def _extract_navigation_intent(self, goal_description: str) -> Optional[str]:
        """
        Extract navigation intent from a goal description.
        Examples:
        - "go to the about page" -> "about page"
        - "navigate to careers section" -> "careers section"
        - "open the dashboard" -> "dashboard"
        """
        # Patterns to extract navigation targets
        patterns = [
            r"go to (?:the )?(.+)",
            r"navigate to (?:the )?(.+)",
            r"open (?:the )?(.+)",
            r"visit (?:the )?(.+)",
            r"take me to (?:the )?(.+)"
        ]
        
        goal_lower = goal_description.lower().strip()
        
        for pattern in patterns:
            match = re.search(pattern, goal_lower)
            if match:
                intent = match.group(1).strip()
                # Clean up common endings
                intent = re.sub(r'\s+(page|section|area)$', r' \1', intent)
                return intent
        
        return None
    
    def _print_goal_summary(self) -> None:
        """Print a summary of all goal statuses"""
        summary = self.goal_monitor.get_status_summary()
        
        print("\nðŸ“Š Goal Summary:")
        print(f"   Total Goals: {summary['total_goals']}")
        print(f"   âœ… Achieved: {summary['achieved']}")
        print(f"   â³ Pending: {summary['pending']}")
        print(f"   âŒ Failed: {summary['failed']}")
        print(f"   â“ Unknown: {summary['unknown']}")
        print(f"   ðŸ”„ Interactions: {summary['interactions_count']}")
        print(f"   â±ï¸  Duration: {summary['session_duration']:.1f}s")
        
        # Print individual goal details
        for goal_name, result in summary['goals'].items():
            status_emoji = {
                GoalStatus.ACHIEVED: "âœ…",
                GoalStatus.PENDING: "â³",
                GoalStatus.FAILED: "âŒ",
                GoalStatus.UNKNOWN: "â“"
            }.get(result.status, "â“")
            
            print(f"   {status_emoji} {goal_name}")
            print(f"      Confidence: {result.confidence:.2f}")
            print(f"      Reasoning: {result.reasoning}")

    def _get_page_info(self) -> PageInfo:
        """Get current page information"""
        try:
            viewport = self.page.viewport_size
            scroll_info = self.page.evaluate("""
                () => ({
                    scrollX: window.scrollX || 0,
                    scrollY: window.scrollY || 0
                })
            """)
            
            return PageInfo(
                width=viewport["width"],
                height=viewport["height"],
                scroll_x=scroll_info["scrollX"],
                scroll_y=scroll_info["scrollY"],
                url=self.page.url,
                title=self.page.title(),
                dpr=self.page.evaluate("window.devicePixelRatio"),
                ss_pixel_w=self.page.evaluate("window.innerWidth"),
                ss_pixel_h=self.page.evaluate("window.innerHeight"),
                css_scale=self.page.evaluate("window.devicePixelRatio"),
                doc_width=self.page.evaluate("document.documentElement.clientWidth"),
                doc_height=self.page.evaluate("document.documentElement.clientHeight")
            )
        except Exception as e:
            print(f"âš ï¸ Error getting page info: {e}")
            # Return safe defaults
            return PageInfo(
                width=1280, height=800, scroll_x=0, scroll_y=0,
                url=self.page.url, title="",
                dpr=1.0,
                ss_pixel_w=1280,
                ss_pixel_h=800,
                css_scale=1.0,
                doc_width=1280,
                doc_height=800
            )

    def _take_screenshot(self) -> bytes:
        """Take a screenshot of the current viewport"""
        return self.page.screenshot(full_page=False)

    def _detect_elements(
        self, 
        goal_description: str, 
        additional_context: str,
        screenshot: bytes, 
        page_info: PageInfo
    ) -> Optional[PageElements]:
        """Detect relevant UI elements using the vision model"""
        
        print(f"Detecting elements for goal: {goal_description}\n")
        
        system_prompt = f"""
        You are a web automation assistant. Look at the screenshot and identify all UI elements.
        
        Current page: {page_info.url}
        Viewport data: {page_info.model_dump_json()}
        
        {f"CONTEXT: {additional_context}" if additional_context else ""}
        
        Instructions:
        1. Analyze the screenshot to identify all UI elements
        2. Focus on elements that help achieve the goal (forms, buttons, links, etc.)
        3. Use Gemini box_2d format: [y_min, x_min, y_max, x_max] normalized to 0-1000
        4. Be conservative - don't include destructive buttons unless specifically asked
        
        Return a list of DetectedElement objects with:
        - element_type: Type of UI element (button, input, link, etc.)
        - description: What this element does
        - box_2d: [y_min, x_min, y_max, x_max] coordinates
        - confidence: How confident you are this element is relevant (0.0-1.0)
        
        IMPORTANT: Use box_2d format [y_min, x_min, y_max, x_max] where:
        - y_min: top edge (0-1000)
        - x_min: left edge (0-1000) 
        - y_max: bottom edge (0-1000)
        - x_max: right edge (0-1000)
        """
        
        user_prompt = "Analyze this screenshot and identify relevant UI elements. Return only the JSON for a list of DetectedElement objects."
        
        try:
            elements = generate_model(
                prompt=user_prompt,
                model_object_type=PageElements,
                reasoning_level="none",
                system_prompt=system_prompt,
                model=self.model_name,
                image=screenshot
            )
            
            # Validate and clamp all coordinates in the detected elements
            if elements:
                elements = self._validate_element_coordinates(elements, page_info)
            
            return elements
        except Exception as e:
            print(f"âŒ Error detecting elements: {e}")
            return None

    def _create_plan(
        self, 
        goal_description: str, 
        additional_context: str,
        detected_elements: PageElements,
        page_info: PageInfo
    ) -> Optional[VisionPlan]:
        """Create an action plan using gpt-5-nano"""
        
        print(f"Creating plan for goal: {goal_description}\n")
        
        system_prompt = f"""
        You are a web automation assistant. Create a plan to achieve the user's goal using the detected UI elements.
        
        Current page: {page_info.url}
        Viewport data: {page_info.model_dump_json()}
        
        USER GOAL: {goal_description}
        {f"CONTEXT: {additional_context}" if additional_context else ""}
        
        DETECTED ELEMENTS: {[elem.model_dump() for elem in detected_elements.elements]}
        
        Instructions:
        1. Analyze the detected elements to understand what's available
        2. Create a plan with 1-3 action steps
        3. Be conservative - don't click destructive buttons unless specifically asked
        4. Focus on the most direct path to achieve the goal
        5. The target_element_index index starts from 0
        
        Return a VisionPlan with:
        - detected_elements: The list of detected elements (use as-is)
        - action_steps: Specific steps to take (can be multiple)
        - reasoning: Why you chose this approach and what was chosen to interact with (must be detailed)
        - confidence: How confident you are (0.0-1.0)
        """
        
        user_prompt = "Create a plan to achieve the goal using the detected elements. Return only the JSON for VisionPlan."
        
        try:
            plan = generate_model(
                prompt=user_prompt,
                model_object_type=VisionPlan,
                reasoning_level="none",
                system_prompt=system_prompt,
                model=self.model_name
            )
            
            return plan
        except Exception as e:
            print(f"âŒ Error creating plan: {e}")
            return None

    def _generate_plan(
        self, 
        goal_description: str, 
        additional_context: str,
        screenshot: bytes, 
        page_info: PageInfo
    ) -> Optional[VisionPlan]:
        """Generate an action plan by first detecting elements then creating a plan"""
        
        # Step 1: Detect relevant UI elements
        detected_elements = self._detect_elements(
            goal_description, additional_context, screenshot, page_info
        )
        
        if not detected_elements:
            print("âŒ No elements detected, cannot create plan")
            return None
        
        # Step 2: Create action plan using detected elements
        plan = self._create_plan(
            goal_description, additional_context, detected_elements, page_info
        )
        
        # Save the bounding box image for debugging
        bounding_box_image = draw_bounding_boxes(screenshot, detected_elements.elements)
        with open("bounding_box_image.png", "wb") as f:
            f.write(bounding_box_image)
        
        return plan

    def _validate_plan_coordinates(self, plan: VisionPlan, page_info: PageInfo) -> VisionPlan:
        """Validate and clamp all coordinates in the generated plan"""
        try:
            # Validate box_2d coordinates for detected elements
            for element in plan.detected_elements.elements:
                if element.box_2d:
                    # box_2d is already validated by the pydantic validator
                    # but we can do additional checks here if needed
                    y_min, x_min, y_max, x_max = element.box_2d
                    
                    # Ensure coordinates are within 0-1000 range (Gemini format)
                    y_min = clamp_coordinate(y_min, 0, 1000)
                    x_min = clamp_coordinate(x_min, 0, 1000)
                    y_max = clamp_coordinate(y_max, 0, 1000)
                    x_max = clamp_coordinate(x_max, 0, 1000)
                    
                    # Ensure min < max
                    if y_min >= y_max:
                        y_max = y_min + 1
                    if x_min >= x_max:
                        x_max = x_min + 1
                        
                    element.box_2d = [y_min, x_min, y_max, x_max]
            
            # Validate direct coordinates in action steps (these are pixel coordinates)
            for step in plan.action_steps:
                if step.x is not None:
                    step.x = clamp_coordinate(step.x, 0, page_info.width - 1)
                if step.y is not None:
                    step.y = clamp_coordinate(step.y, 0, page_info.height - 1)
                    
        except Exception as e:
            print(f"âš ï¸ Error validating plan coordinates: {e}")
        
        return plan

    def _validate_element_coordinates(self, elements: PageElements, page_info: PageInfo) -> PageElements:
        """Validate and clamp all coordinates in the detected elements"""
        try:
            for element in elements.elements:
                if element.box_2d:
                    # box_2d is already validated by the pydantic validator
                    # but we can do additional checks here if needed
                    y_min, x_min, y_max, x_max = element.box_2d
                    
                    # Ensure coordinates are within 0-1000 range (Gemini format)
                    y_min = clamp_coordinate(y_min, 0, 1000)
                    x_min = clamp_coordinate(x_min, 0, 1000)
                    y_max = clamp_coordinate(y_max, 0, 1000)
                    x_max = clamp_coordinate(x_max, 0, 1000)
                    
                    # Ensure min < max
                    if y_min >= y_max:
                        y_max = y_min + 1
                    if x_min >= x_max:
                        x_max = x_min + 1
                        
                    element.box_2d = [y_min, x_min, y_max, x_max]
            
        except Exception as e:
            print(f"âš ï¸ Error validating element coordinates: {e}")
        
        return elements

    def _execute_plan(self, plan: VisionPlan, page_info: PageInfo) -> bool:
        """Execute the generated plan"""
        print(f"ðŸš€ Executing plan with {len(plan.action_steps)} steps")
        
        for i, step in enumerate(plan.action_steps):
            print(f"\n  Step {i+1}: {step.action}")
            
            try:
                if step.action == ActionType.CLICK:
                    self._execute_click(step, plan.detected_elements, page_info)
                elif step.action == ActionType.TYPE:
                    self._execute_type(step, plan.detected_elements, page_info)
                elif step.action == ActionType.SCROLL:
                    self._execute_scroll(step)
                elif step.action == ActionType.WAIT:
                    self._execute_wait(step)
                else:
                    print(f"âš ï¸ Unknown action type: {step.action}")
                    continue
                
                # Record this action
                self.executed_actions.append(step)
                
                # Small delay between actions
                time.sleep(0.5)
                
            except Exception as e:
                print(f"âŒ Error executing step {i+1}: {e}")
                return False
        
        print("âœ… Plan execution completed")
        return True

    def _execute_click(self, step: ActionStep, elements: PageElements, page_info: PageInfo):
        """Execute a click action"""
        x, y = self._get_click_coordinates(step, elements, page_info)
        if x is None or y is None:
            raise ValueError("Could not determine click coordinates")
        
        # Validate and clamp coordinates to viewport
        x, y = validate_and_clamp_coordinates(x, y, page_info.width, page_info.height)
        
        # Record planned interaction with goal monitor and get pre-interaction evaluations
        pre_evaluations = self.goal_monitor.record_planned_interaction(
            InteractionType.CLICK,
            coordinates=(x, y)
        )
        
        # Check if any goals were achieved before the click
        if any(result.status == GoalStatus.ACHIEVED for result in pre_evaluations.values()):
            print("ðŸŽ¯ Goal achieved before click! Proceeding with click to complete the interaction.")
            for goal_name, result in pre_evaluations.items():
                if result.status == GoalStatus.ACHIEVED:
                    print(f"   âœ… {goal_name}: {result.reasoning}")
        elif any(result.status == GoalStatus.FAILED for result in pre_evaluations.values()):
            print("âš ï¸ Goal evaluation suggests this click may not achieve the target:")
            for goal_name, result in pre_evaluations.items():
                if result.status == GoalStatus.FAILED:
                    print(f"   âŒ {goal_name}: {result.reasoning}")
            # Continue with click anyway - the user's plan should be executed
        
        print(f"Elements: {elements.model_dump_json()}")
        print(f"Step: {step.model_dump_json()}")
        print(f"  Clicking at ({x}, {y})")
        
        try:
            self.page.mouse.click(x, y)
            success = True
            error_msg = None
        except Exception as e:
            success = False
            error_msg = str(e)
            print(f"  âŒ Click failed: {e}")
        
        # Record actual interaction with goal monitor
        self.goal_monitor.record_interaction(
            InteractionType.CLICK,
            coordinates=(x, y),
            success=success,
            error_message=error_msg
        )

    def _execute_type(self, step: ActionStep, elements: PageElements, page_info: PageInfo):
        """Execute a type action"""
        if not step.text_to_type:
            print("âš ï¸ No text specified for TYPE action")
            return
        
        # Click first to focus the element
        x, y = self._get_click_coordinates(step, elements, page_info)
        if x is not None and y is not None:
            # Validate and clamp coordinates to viewport
            x, y = validate_and_clamp_coordinates(x, y, page_info.width, page_info.height)
            self.page.mouse.click(x, y)
            time.sleep(0.2)
        
        print(f"  Typing: {step.text_to_type}")
        
        try:
            # Clear existing text first
            self.page.keyboard.press("Control+a")
            self.page.keyboard.type(step.text_to_type, delay=50)
            success = True
            error_msg = None
        except Exception as e:
            success = False
            error_msg = str(e)
            print(f"  âŒ Typing failed: {e}")
        
        # Record type interaction with goal monitor
        self.goal_monitor.record_interaction(
            InteractionType.TYPE,
            coordinates=(x, y) if x is not None and y is not None else None,
            text_input=step.text_to_type,
            success=success,
            error_message=error_msg
        )

    def _execute_scroll(self, step: ActionStep):
        """Execute a scroll action"""
        direction = step.scroll_direction or "down"
        scroll_amount = 300
        
        if direction == "up":
            scroll_amount = -scroll_amount
        
        print(f"  Scrolling {direction}")
        self.page.evaluate(f"window.scrollBy(0, {scroll_amount})")

    def _execute_wait(self, step: ActionStep):
        """Execute a wait action"""
        wait_time = step.wait_time_ms or 500
        print(f"  Waiting {wait_time}ms")
        time.sleep(wait_time / 1000)

    def _get_click_coordinates(self, step: ActionStep, elements: PageElements, page_info: PageInfo) -> Tuple[Optional[int], Optional[int]]:
        """Get the coordinates to click based on the step"""
        # If direct coordinates are provided, use them
        if step.x is not None and step.y is not None:
            return int(step.x), int(step.y)
        
        # If target element index is provided, use element center
        if step.target_element_index is not None:
            if 0 <= step.target_element_index < len(elements.elements):
                element = elements.elements[step.target_element_index]
                if element.box_2d:
                    # Convert Gemini box_2d to pixel coordinates
                    center_x, center_y = get_gemini_box_2d_center_pixels(
                        element.box_2d, page_info.width, page_info.height
                    )
                    if center_x > 0 or center_y > 0:  # Valid center found
                        return center_x, center_y
        
        return None, None

    def _scroll_page(self):
        """Scroll the page to break loops"""
        self.page.evaluate("window.scrollBy(0, 200)")
        time.sleep(0.5)

    def _is_goal_achieved(self, goal: Goal) -> bool:
        """Check if the goal has been achieved"""
        try:
            # Check URL contains target strings
            if goal.target_url_contains:
                current_url = self.page.url.lower()
                if not any(target.lower() in current_url for target in goal.target_url_contains):
                    return False
            
            # Check page contains target text
            if goal.target_page_text:
                page_text = self.page.evaluate("document.body.innerText").lower()
                if not any(target.lower() in page_text for target in goal.target_page_text):
                    return False
            
            # Check if form is filled (basic check)
            if goal.form_should_be_filled:
                empty_required_fields = self.page.evaluate("""
                    () => {
                        const inputs = document.querySelectorAll('input[required], select[required], textarea[required]');
                        return Array.from(inputs).filter(input => !input.value.trim()).length;
                    }
                """)
                if empty_required_fields > 0:
                    return False
            
            return True
            
        except Exception as e:
            print(f"âš ï¸ Error checking goal achievement: {e}")
            return False

    # =========================================================================
    # Convenience Methods
    # =========================================================================

    def click_element(self, description: str) -> bool:
        """Convenience method to click an element by description"""
        return self.achieve_goal(f"Click the {description}")

    def fill_form_field(self, field_name: str, value: str) -> bool:
        """Convenience method to fill a form field"""
        return self.achieve_goal(f"Fill the {field_name} field with '{value}'")

    def navigate_to_page(self, page_description: str) -> bool:
        """Convenience method to navigate to a page"""
        return self.achieve_goal(f"Navigate to the {page_description} page")


# =============================================================================
# Example Usage
# =============================================================================

if __name__ == "__main__":
    from playwright.sync_api import sync_playwright

    def init_browser():
        p = sync_playwright().start()
        browser = p.chromium.launch(headless=False)
        context = browser.new_context(
            viewport={"width": 1280, "height": 800},
            device_scale_factor=1
        )
        page = context.new_page()
        page.goto("https://example.com", wait_until="domcontentloaded")
        return p, browser, page

    # Initialize browser and bot
    playwright, browser, page = init_browser()
    bot = VisionBot(page, model_name="gemini-2.5-flash-lite")

    try:
        # Try to achieve a goal
        success = bot.achieve_goal("Click on the 'More information...' link")
        
        if success:
            print("ðŸŽ‰ Goal achieved successfully!")
            bot.page.pause()
        else:
            print("ðŸ˜ž Failed to achieve goal")
    finally:
        browser.close()
        playwright.stop()
